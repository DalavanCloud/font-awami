/*
    File: nastaliq_rules.gdl

    Graphite positioning rules for Awami Nastaliq
*/


table(positioning)

pass(1)

//
//	CURSIVE ATTACHMENT
//

#define cursive_attach(P)  c_exit_##P {att {to=@L; with=exit_##P; at=entr_##P}} c_entr_##P {insert=1} / _ MARKS2N ^ _=L ;

// Only used for beh so we don't need to allow upper and lower diacs:
#define cursive_attach2(P1, P2)  c_exit_##P1 {att {to=@L; with=exit_##P1; at=entr_##P2}} c_entr_##P2 {insert=1} / _ MARKS ^ _=L ;


#if (QUICKCOMPILE == 0)

cursive_attach(beh)
cursive_attach(behFinal)
cursive_attach(behHighTooth)
cursive_attach(behLowTooth)
cursive_attach2(behLowTooth, behPreFinalHehGoal)
cursive_attach(behPreReh)
cursive_attach(behPreNoon)
cursive_attach(jeem)
cursive_attach(reh)
cursive_attach(rehHgm)
cursive_attach(rehJkl)
cursive_attach(rehSshg)
cursive_attach(seen)
cursive_attach(sad)
cursive_attach(tah)
cursive_attach(ain)
cursive_attach(feh)
cursive_attach(meem)
cursive_attach(meemAlt)
cursive_attach(noon)
cursive_attach(hehgoalMedial)
cursive_attach(hehgoalFinal)
cursive_attach(hehdoach)
cursive_attach(chotiyeh)
cursive_attach(chotiyehBfkl)
cursive_attach(bariyeh)
cursive_attach(lamKaf)
cursive_attach(kafAlt)
cursive_attach(qafWaw)
cursive_attach(qafWawStfh)

#endif  // QUICKCOMPILE

// EXPERIMENTS
#define REDUCE_KERN 60m
#define SHIFT_N_OUT 0m

// Last resort:
(c_initial c_medial) {att.to=@L} (c_medial  c_final) {insert=1}  / _ MARKS2N ^ _=L ;


if (overlapKern == tight)
g_space { advance.x = 0m; };
endif;

if (overlapKern == medium)
g_space { advance.x = 280m - REDUCE_KERN; };
endif;

if (overlapKern == wide)
g_space {advance.x = 450m; };
endif;

endpass; // 1

endtable;	// positioning


// TEMPORARY
table(glyph)

c_initial { zeroS = point(0m, 0m) };
c_medial  { zeroS = point(0m, 0m) };
c_final   { zeroS = point(0m, 0m) };

cNuqtaLike { zeroM = point(0m, 0m); zeroS = point(0m, 0m) };

cDiacritic { zeroM = point(0m, 0m) };

endtable;


//
//  NUQTA POSITIONING
//

table(positioning)

pass(2)

// Upper and lower nuqta attachment


table(glyph)

// For some reason I have to subtract something to make these things work. :-/
cn1LowerDia { nByLowerM = point(n1LowerM.x, n1LowerM.y - 1m) };
cn23LowerDia { nByLowerM = point(n23LowerM.x, n23LowerM.y - 1m) };

cTakes_nLowerDia = (cTakes_n1LowerDia cTakes_n23LowerDia);

endtable;

// Special bariyeh rules: move any nuqtas within three chars of a bariyeh down.

// X+Nx  Y+Ny  Z+Nz  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	cMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = n23LowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+Nx  Y  Z+Nz  Bariyeh
// Here we attach the upper nuqta too, since if we back up to attach it, it will reattach and mess up
// the second lower nuqta.
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	c_medial   cNuqtaLikeUpper   {                 attach {to = @Y; at = nUpperS; with = nUpperM } }
	cMedBy cNuqtaLower       { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  c_medial=Y DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+Nx  Y+Ny  Z  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidLeftLowerS; with = nByLowerM } }
	/ _=B1 _=L1 DIACS  _=B2  _=L2  DIACS  ^ cMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;

// X+Nx  Y+Ny  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidRightLowerS; with = nByLowerM } }
	cMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y  _=Ny DIACS  ^ gBariyehFin=By;

// X+Nx Y Bariyeh 
cTakes_nLowerDia  cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	/ _=B _=L  DIACS  ^ cMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;



// Not really needed, because all glyphs with lower diacs can take upper diacs
//table(glyph)
//cTakes_n1Lower_and_nUpperDia = cTakes_n1LowerDia;
//cTakes_n1Lower_and_nUpperDia &= (cTakes_nUpperDia);
//endtable;

// tah above, nuqta(s) below
cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=L  _=U;

// nuqtas above, hehhook below
cTakes_hehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// nuqtas above and below
cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;


// Upper nuqta attachment

////gJeemFin  cNuqtaLike { attach {to = @J; at = point(574m, 1274m); with = nUpperM} }
////	/  gJeemMedJm=J  cNuqtaLike?  _  _;

//cTakes_n1hUpperBehSpecialDia
//	cNuqtaLikeUpper { attach {to = @B; at = n1hUpperBehSpecialS; with = nUpperM } }
//	/ _=B  _=U;

// Experiment - moving nuqtas out
/***/
table(glyph)
cBehIniMed = (cBehIni cBehMed);
cFehIniMed = (cFehIni cFehMed);
cJeemIniMed = (cJeemIni cJeemMed);
cTakes_nUpperDia { nUpperSAlt = point(nUpperS.x, nUpperS.y + SHIFT_N_OUT) };
endtable; // glyph

(cFehIniMed cFehIni cBehIniMed) cnUpperDia { attach {to = @B; at = nUpperSAlt; with = nUpperM } } / _=B  _=U;
/***/
///////////////////////



cTakes_nUpperDia
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=U;

cTakes_tahUpperDia
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=U;

cTakes_hamzaUpperDia
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=U;


// Lower nuqta attachment

// Experiment - moving nuqtas out
/****/
table(glyph)
//cBehIniMed = (cBehIni cBehMed);
cTakes_n1LowerDia { n1LowerSAlt = point(n1LowerS.x, n1LowerS.y - SHIFT_N_OUT) };
cTakes_n23LowerDia { n23LowerSAlt = point(n23LowerS.x, n23LowerS.y - SHIFT_N_OUT) };
endtable; // glyph

cBehIniMed cn1LowerDia { attach {to = @B; at = n1LowerSAlt; with = n1LowerM } }  / _=B  _=L;
cBehIniMed cn23LowerDia { attach {to = @B; at = n23LowerSAlt; with = n23LowerM } } / _=B  _=L;
cJeemIniMed cn1LowerDia { attach {to = @B; at = n1LowerSAlt; with = n1LowerM } }  / _=B  _=L;
/****/
///////////////////////


cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	/ _=B  _=L;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	/ _=B  _=L;

cTakes_tahLowerDia
	ctahLowerDia { attach {to = @B; at = tahLowerS; with = tahLowerM } }
	/ _=B  _=U;

// Hehhook
cTakes_hehhookDia  g__hehHook_small  { attach {to = @B; at = hehhookS; with = hehhookM } }
	/ _=B  _=H;

// Hehhook - big
////////attachR_BN(	gHehGoalIni,	g__hehHook_big,		default2,		default2_)


// TEMPORARY - fall-back attachment
// Needed to test in Graphite1.
(c_initial c_medial c_final)  cNuqtaLike { attach {to = @1; at = zeroS; with = zeroM } };

endpass;  // 2

endtable;  // pos


#if DO_COL_FIX

table(glyph) {AttributeOverride = 0}

// Define for all needed glyphs where they have not been defined in the font.
c_initial {kernBbRightS = point(0m,0m) };
c_final {kernBbLeftS = point(0m,0m) };
c_isolated {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };
gComma {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };
gFullStop {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };

endtable;


table(glyph)

cPostKernable = (c_initial c_isolated) {
	tempBbRight = bb.right; tempRsb = rsb; tempAdv = advancewidth;
	kernRsb = advancewidth - ((kernBbRightS.x == 0) ? bb.right : kernBbRightS.x);
};

cKernable = (c_isolated c_final gComma gFullStop)
{
	//// collision.kern = true;
	tempBbLeft = bb.left; tempLsb = lsb;
	kernLsb = ((kernBbLeftS.x == 0) ? bb.left : kernBbLeftS.x);
}



c_jumpTail = ( cJeemFin, gAinFin, gGhainFin );

// TODO: do exclusion glyphs correctly.
// TODO: don't use them for ngoeh
////gKafMedSn		{ collexclude {glyph = g__kaf_exclude;		offsetx=kafExcludeS.x;	offsety=kafExcludeS.y;}};
////gGafMedBe_alt	{ collexclude {glyph = g__kaf_alt_exclude;	offsetx=-100m;	offsety=750m;}};
////gGafMedSn_alt	{ collexclude {glyph = g__kaf_alt_exclude;	offsetx=-200m;	offsety=650m;}};
////gGafMed_short	{ collexclude {glyph = g__kaf_exclude;		offsetx=200m;	offsety=-200m;}};
////gKafFin			{ collexclude {glyph = g__kaf_exclude;		offsetx=1800m;	offsety=0m;}};

/*
c__kaf_exclude = (g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, 
	g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude,
	g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude,
	g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude,
	g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude, g__kaf_exclude,
	g__kaf_exclude, g__kaf_exclude, g__kaf_exclude);
cls_excludingGlyphs = (cKafMed)
	{collexclude {glyph = c__kaf_exclude; offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};
*/

gKafMed {collexclude.glyph = g__kaf_exclude};
gKafMedBeF {collexclude.glyph = g__kaf_exclude};
gKafMedBeM2 {collexclude.glyph = g__kaf_exclude};
gKafMedJm {collexclude.glyph = g__kaf_exclude};
gKafMedRe {collexclude.glyph = g__kaf_exclude};
gKafMedSn {collexclude.glyph = g__kaf_exclude};
gKafMedSd {collexclude.glyph = g__kaf_exclude};
gKafMedTaF {collexclude.glyph = g__kaf_exclude};
gKafMedAi {collexclude.glyph = g__kaf_exclude};
gKafMedFe {collexclude.glyph = g__kaf_exclude};
gKafMedQf {collexclude.glyph = g__kaf_exclude};
gKafMedMm {collexclude.glyph = g__kaf_exclude};
gKafMedNn {collexclude.glyph = g__kaf_exclude};
gKafMedHgF {collexclude.glyph = g__kaf_exclude};
gKafMedHd {collexclude.glyph = g__kaf_exclude};
gKafMedCh {collexclude.glyph = g__kaf_exclude};
gKafMedBy {collexclude.glyph = g__kaf_exclude};
gKafMedDk {collexclude.glyph = g__kaf_exclude};
gKafMedBeRe {collexclude.glyph = g__kaf_exclude};
gKafMedBeNn {collexclude.glyph = g__kaf_exclude};
gKafMedBeHg {collexclude.glyph = g__kaf_exclude};
gGafMed {collexclude.glyph = g__kaf_exclude};
gGafMedBeF {collexclude.glyph = g__kaf_exclude};
gGafMedBeM2 {collexclude.glyph = g__kaf_exclude};
gGafMedJm {collexclude.glyph = g__kaf_exclude};
gGafMedRe {collexclude.glyph = g__kaf_exclude};
gGafMedSn {collexclude.glyph = g__kaf_exclude};
gGafMedSd {collexclude.glyph = g__kaf_exclude};
gGafMedTaF {collexclude.glyph = g__kaf_exclude};
gGafMedAi {collexclude.glyph = g__kaf_exclude};
gGafMedFe {collexclude.glyph = g__kaf_exclude};
gGafMedQf {collexclude.glyph = g__kaf_exclude};
gGafMedMm {collexclude.glyph = g__kaf_exclude};
gGafMedNn {collexclude.glyph = g__kaf_exclude};
gGafMedHgF {collexclude.glyph = g__kaf_exclude};
gGafMedHd {collexclude.glyph = g__kaf_exclude};
gGafMedCh {collexclude.glyph = g__kaf_exclude};
gGafMedBy {collexclude.glyph = g__kaf_exclude};
gGafMedDk {collexclude.glyph = g__kaf_exclude};
gGafMedBeRe {collexclude.glyph = g__kaf_exclude};
gGafMedBeNn {collexclude.glyph = g__kaf_exclude};
gGafMedBeHg {collexclude.glyph = g__kaf_exclude};

// Note gGafMed_short doesn't need an exclude glyph because it is tucked under the following kaf/gaf so there
// isn't room for anything to jump above it anyway.

cls_excludingGlyphs = (cKafMed)
	{collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

gKafFin {collexclude.glyph = g__kaf_exclude};
gGafFin {collexclude.glyph = g__kaf_exclude};

cls_excludingGlyphs_kern = (gKafFin, gGafFin)
	{collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

endtable;


// Nuqta collision fixing

table(positioning)

pass(3)

// Set up for collision fixing

#define MAXKERN 5000m
#define MINKERN -700m
#define MINKERN_TIGHT -3000m
#define MINKERN_WIDE -200m
#define STDMARGIN 150m
#define STDMARGINWT 400
#define STDMARGIN_N1 150m
#define STDMARGINWT_N1 200
#define STDMARGIN_N2 150m
#define STDMARGINWT_N2 200
#define STDMARGIN_DIAC 200m
#define STDMARGINWT_DIAC 400

#define KERNMARGIN_TIGHT 150m
#define KERNMARGIN_MED 300m
#define KERNMARGIN_WIDE 400m


#define ORDER_UNUQTAS 1
#define ORDER_LNUQTAS 2
#define ORDER_LNUQTAS_SUB_BYEH 3

#define ORDER_UDIACS 4
#define ORDER_LDIACS 5

table(glyph) {AttributeOverride = 1}

cNuqtaLikeUpper {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_UNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 50 };
		valign { height = 200m;	weight = 500 }
	}
};

cNuqtaLikeLower {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_LNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 500 }; // weight was 50
		valign { height = 200m;	weight = 500 }
	}
};

// Smaller nuqta glyphs need larger margins:
g__dot1u { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };		// was 150
g__dot1l { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };		// was 150
g__dot2u { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };		// was 125
g__dot2l { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };		// was 125


cDiacriticUpper {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; } - set in the rule
};

gNoonGhunnaMark { collision.margin = 300; marginweight = 300 }; // override

cBase = (c_initial, c_medial, c_final);

cDiacriticLower {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; } - set in the rule
};

//cNuqtaLikeAbove { collision.order { class = ORDER_UNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };
//cNuqtaLikeBelow { collision.order { class = ORDER_LNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };

endtable; // glyph


// Spaces serve as boundaries between collision ranges.
g_space { collision.flags = SET_START_END(collision.flags) };


// Upper nuqtas

// Special case: if there is a nuqta before a zah, scootch the nuqta of the
// zah down pretty close to the base.
/**
cNuqtaLikeUpper { 
	shift{ x = 50m; y = -150m }; // note that shifting in RTL moves forward, ie, left.
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 100m;
		min.y = -100m;
		max.y = 300m;
	}
} /  cNuqtaLikeUpper=N1 DIACS  cTahMed  _=N2 ;
**/


// The nuqta on the zah (tah form) fits nicely above it, so it is not normally helpful to move it.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;   // don't let this one move left much
	max.x = 100m;
	min.y = -200m;  // shouldn't need to move vertically either, at least by much
	max.y = 300m;
} } / cTahMed _ ;


// Special cases involving kaf tops - allow nuqtas to move further right than normal.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 800m; // a lot more than normal
	min.y = -300m;
	max.y = 1000m;
} } / _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed gKafFin);


// Need more flexibility in getting away from kinked kafs
// TODO: use a class including all kinked kafs.
g__dot3u { collision {
	flags = SET_FIX(collision.flags);
	min.x = -500m;
	max.x = 250m;
	min.y = -300m;
	max.y = 1000m;
} } / (gGafMedBe_alt gGafMedSn_alt gKafIniBeM2_alt)  cBase _ ;


// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m; // more than normal
	min.y = -300m;
	max.y = 1000m;
} } / c_initial _;

// Nuqtas on finals can be moved quite a bit to the left.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -500m;   // more than normal
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } / c_final _;

// Default case: nuqtas above (other than initial) can move more to the left than the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} };


// Lower nuqtas

// Nuqtas before certain finals can move down quite a bit to jump below swashes.
// Note that if we make the lower limit too low, the nuqtas will jump completely *below* 
// the swash, which is not what we want. We want to be down and to the right.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 700m;	// a lot!
		min.y = -1600m; // a lot!
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / _  c_jumpTail;

// Nuqtas below a bariyeh cannot move up, and they don't flow diagonally.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -400m;
		max.x = 400m;
		min.y = -100m;
		max.y = 0m;
  };
  sequence { class = 0; order = 0 }
} / c_initial?  _ {underBy == true};


// Heh-hooks need to be kept centered under the base.
g__hehHook_small { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 50m;
	min.y = -1000m;
	max.y = 50m;
} };

// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 400m;  // 600 breaks \u067E\u0650\u06CC\u064F\u0648
	min.y = -1000m;
	max.y = 300m;
} }  /  c_initial  _;

// Default case: nuqtas below (other than initial) can move more to the right than the left.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 350m;   // making this 400 helps \u067E\u0650\u06CC\u0686\u06BE\u06D2 but breaks other things
	min.y = -1000m;
	max.y = 300m;
} };

// experiment
cls_excludingGlyphs { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} };

// experiment
cls_excludingGlyphs_kern { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	max.x = MAXKERN; min.x = MINKERN;
	margin = 100m;
    // min/max.y are omitted for kernable glyphs
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} };


// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.
// We actually set the kerning parameters in the final pass. But here, at least indicate
// which glyphs can be kerned, which affects how shifting works around them.

cKernable { collision {
	//---flags = SET_FIX(collision.flags); -- move actual kerning to end of process
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	////max.x = 300m; min.x = 0;  // kerning right is logically equivalent to shifting left in RTL
	//---max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


// Other bases are not moved.
(c_initial c_medial) { collision { flags = COLL_FREEZE } };

cDiacritic { collision.flags = SET_IGNORE(collision.flags) };	// these have not been attached, so don't bother with them

endpass; // 3


// We put the actual collision fixing a separate pass just because it makes debugging easier.
if (collFix > 1)
pass(4) { CollisionFix = 5 }
// Perform base + nuqta collision fixing. Any failures leave for now.
endpass;
endif;

/**************************************

#define CHARSEQ cMed cNuqtaLike? cDiacritic?
#define SEQ2 [[CHARSEQ]? CHARSEQ]?
#define SEQ3 [[[CHARSEQ]? CHARSEQ]? CHARSEQ]?
#define YBELOWBYEH -450

if (collFix > 1)
pass(4) { CollisionFix = 4 }

// Next: adjust for nuqtas moved below a bariyeh.
// Needed for, eg, \u0686\u067E\u0679\u06CC\u0646\u06D2

cNuqtaLikeLower {
	collision.max.y = 0m; // ideally this would be set to what it is shifted by already
	sequence { class = ORDER_LNUQTAS_SUB_BYEH; order = 0 }
}  / (c_medial c_initial)  _ {position.y < 0}  cDiacritic?  SEQ2 gBariyehFin;

// Nuqtas still above a bariyeh need more flexibility; if they are initial, let them move right:
cNuqtaLikeLower {
	collision.max.x = 750m;
	sequence.class = 0;
}  / cIni  _ {position.y > 100m}  cDiacritic?  SEQ2 gBariyehFin;


endpass;  // 4
endif;    // collFix > 1

*****************************************/

endtable;

#endif // DO_COL_FIX


table(positioning)

//
//	DIACRITIC ATTACHMENT
//

table(glyph)

c_final_wo_diac = cFin;
c_final_wo_diac -= (gWawHamzaAboveFin, gWawHamzaAboveFin_stfh, gAlefMaddaFin, gLamAlefMaddaFin, gAlefHamzaFin, gLamAlefHamzaFin,
	gHehGoalHamzaFin, gHehGoalHamzaFin_stfh, gYehHamzaAboveFin);
	

// many diacritics are attached to initials and medials as if they were nuqtas - but not all
c_base_wo_diac = (cIni cMed c_final_wo_diac cIso);

c_base_wo_nuqta = (cIni cMed);

endtable;  // glyph


// Order of glyphs: base, nuqta below, nuqta above, diacritics below, diacritics above

#if DO_COL_FIX
pass(5)
#else
pass(3)
#endif // DO_COL_FIX


// Attach diacritics
 
table(glyph) { AttributeOverride = false }
// Classes of nuqtas and things that attach closely like nuqtas:
c_attLikeNqUpper = (cNuqtaLikeUpper); // includes small tah
c_attLikeNqLower = (cNuqtaLikeLower, g__hehHook_small);
endtable;


// attach to nuqta
cTakes_mUpperDia  c_attLikeNqUpper=N  cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _  c_attLikeNqLower?  _  cDiacriticLower? _ {att.to==0};
cTakes_mLowerDia  c_attLikeNqLower=N  cDiacriticLower {att {to=@N; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _  _  c_attLikeNqUpper?  _ {att.to==0};

// Attaching to final form, or nuqta, uses mUpper/LowerS.
cTakes_mUpperDia=B  cDiacriticUpper {att {to=@B; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _  c_attLikeNqLower?  cDiacriticLower?  _ {att.to==0};
cTakes_mLowerDia=B  cDiacriticLower {att {to=@B; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _  c_attLikeNqUpper?  _ {att.to==0};

// Attaching to initial/medial base - uses stationary nuqta APs.
cTakes_nUpperDia=B  cDiacriticUpper {att {to=@B; at=nUpperS; with=mUpperM}; insert=true}
		/ ^ _  c_attLikeNqLower?  cDiacriticLower?  _ {att.to==0};
cTakes_n1LowerDia=B  cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}; insert=true}
		/ ^ _  c_attLikeNqUpper?  _ {att.to==0};

// attach to diacritic
cDiacriticUpper=D1  cDiacriticUpper {att {to=@D1; at=mUpperS; with=mUpperM}; insert=true}  / _ ^ _;
cDiacriticLower=D1  cDiacriticLower {att {to=@D1; at=mLowerS; with=mLowerM}; insert=true}  / _ ^ _;

// Remove if we create a nuqta+smalltah glyph:
////c_attLikeNqUpper=N  g__smallTah=T {att {to=@N; at=mUpperS; with=mUpperM} };

endpass; // pos - 5 (or 3)


// Kerning pair adjustments - EXPERIMENTAL

#define pairKern user2

table(glyph) { AttributeOverride = 1 }

// alef, dal, reh, reh-sshg, reh-jkl, reh-???, waw, heh-goal, noon

cKernable { kernPreAlef = 50m; kernPreDal = 0m; kernPreReh = 0m; kernPreWaw = 0m; kernPreInitial = 0m };

gAlef { kernPreAlef = 50m; kernPreDal = 50m; kernPreReh = 50m; kernPreWaw = 50m };
gAlefFin { kernPreAlef = 50m; kernPreDal = 50m; kernPreReh = 50m; kernPreWaw = 50m };

gReh { kernPreInitial = -150m };

gRehFin { kernPreDal = 100m };
gRehFin_sshg { kernPreWaw = 100m };

gWaw { kernPreReh = -75m };
gWawFin { kernPreReh = -75m };

endtable; // glyph

// Set up kerning pairs.

pass(6)

cKernable { pairKern = kernPreAlef }  /  _  g_space?  gAlef;
cKernable { pairKern = kernPreDal  }  /  _  g_space?  gDal;
cKernable { pairKern = kernPreReh  }  /  _  g_space?  gReh;
cKernable { pairKern = kernPreWaw  }  /  _  g_space?  gWaw;
(gReh gZain) { pairKern = kernPreInitial }
						/  _  g_space?  cPostKernable;  // need to include 3 slots to give  
														// this rule adequate precedence
///cKernable { pairKern = 0m }           /  _  g_space?  cPostKernable;

endpass;  // 6


#if DO_COL_FIX

// Diacritic collision fixing and kerning


pass(7) // { CollisionFix = 4; AutoKern = true }

// Set up diacritic collision fixes and kerning.

// Spaces serve as boundaries between collision ranges.
g_space { collision.flags = COLL_START + COLL_END };

// Kaf exclusion glyphs don't affect diacritics.
(cls_excludingGlyphs cls_excludingGlyphs_kern) { collision.exclude.glyph = 0 };

gNameMarker  { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -400m;
	max.x = 400m;
	min.y = -300m;
	max.y = 800m;
} };

// Diacritics attached to bases:
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  cBase  cNuqtaLikeLower?  _;


cDiacriticLower { 
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -300m; // making this larger than ideal fixes \u0628\u0650\u06CC\u062C
		max.x = 300m;
		min.y = -1200m; // needed to get below nuqtas for sure; eg \u062A\u0648\u0641\u0650\u06CC\u0642
		max.y = 300m;
	};
	sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; }
}  /  cBase  cNuqtaLikeUpper?  _;


cDiacriticUpper { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 250m;
	min.y = -300m;
	max.y = 500m;
} };


cDiacriticLower { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -300m; // making these larger than ideal fixes \u0628\u0650\u06CC\u062C
	max.x = 300m;
	min.y = -800m;
	max.y = 300m;
} };


// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.
if (overlapKern == none)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = 0;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == wide)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
//	max.x = MAXKERN; min.x = MINKERN_TIGHT; margin = KERNMARGIN_MED;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == medium)

// For short sequences ending with bariyeh, kern against the bariyeh tail, not the initial.

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0, kernLsb + 140m);  // 140m = bariyeh's rsb
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  g_space?  c_initial cNuqtaLike? DIACS [c_medial cNuqtaLike? DIACS]? 
		gBariyehFin=F;

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb - REDUCE_KERN + pairKern);
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  g_space?  cPostKernable=N;

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == tight)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN_TIGHT;
    // min/max.y are omitted for kernable glyphs
} };

endif;

cls_excludingGlyphs { collision { flags = CLEAR_FIX(collision.flags); exclude.glyph = 0 }};


cNuqtaLike { collision.flags = CLEAR_FIX(collision.flags) };
/////cKernable { collision.flags = CLEAR_FIX(collision.flags) }; - if kerning is done earlier

endpass;


// We put the actual collision fixing a separate pass just because it makes debugging easier.

if (collFix > 0)
pass(8) { CollisionFix = 4; AutoKern = true }
// Perform diacritic-related fixing.
endpass;
endif;

#endif // DO_COL_FIX


/////#include "awami_tweaks.gdh"

endtable;

