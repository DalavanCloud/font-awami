/*
    File: nastaliq_rules.gdl

    Graphite rules for Awami Nastaliq
*/

// Standard definitions and abbreviations:
#include "stddef.gdh"

// Collision fixing:
#define DO_COL_FIX 1

// Separate the nuqtas on final glyphs from their bases:
#define SEP_FINAL_NUQTAS 0

// just for testing the end of the compilation process; doesn't generate a workable font
#define QUICKCOMPILE 0


Bidi = true;
ScriptDirection = HORIZONTAL_RIGHT_TO_LEFT;


#if DO_COL_FIX

#define COLL_FREEZE       0		// base - test for collisions but don't move this glyph; 
                           		// the default for a glyph in the START-END range
#define COLL_FIX          1
#define COLL_IGNORE       2
#define COLL_START        4
#define COLL_END          8
#define COLL_KERN        16
//      COLL_ISCOL       32		// this glyph has a collision
//      COLL_KNOWN       64		// we've figured out what's happening with this glyph
#define COLL_JUMPABLE   128
#define COLL_OVERLAP    256

#define setbits(f,m,v) (f & (~m)) | v


#define SET_FIX(f) 			setbits(f, COLL_FIX, COLL_FIX)
#define CLEAR_FIX(f) 		setbits(f, COLL_FIX, 0)
#define SET_IGNORE(f)		setbits(f, COLL_IGNORE, COLL_IGNORE)
#define CLEAR_IGNORE(f)		setbits(f, COLL_IGNORE, 0)
#define SET_START(f)		setbits(f, COLL_START, COLL_START)
#define CLEAR_START(f)		setbits(f, COLL_START, 0)
#define SET_END(f)			setbits(f, COLL_END, COLL_END)
#define CLEAR_END(f)		setbits(f, COLL_END, 0)
#define SET_KERN(f)			setbits(f, COLL_KERN, COLL_KERN)
#define CLEAR_KERN(f)		setbits(f, COLL_KERN, 0)
#define SET_JUMPABLE(f)		setbits(f, COLL_JUMPABLE, COLL_JUMPABLE)
#define CLEAR_JUMPABLE(f)	setbits(f, COLL_JUMPABLE, 0)
#define SET_OVERLAP(f)		setbits(f, COLL_OVERLAP, COLL_OVERLAP)
#define CLEAR_OVERLAP(f)	setbits(f, COLL_OVERLAP, 0)

#define SET_START_END(f)	setbits(f, (COLL_START + COLL_END), (COLL_START + COLL_END))

#define ORDER_LEFTDOWN	1
#define ORDER_RIGHTUP	2
#define ORDER_NOABOVE	4
#define ORDER_NOBELOW	8

#endif // DO_COL_FIX


// 1 means strip out the nuqtas altogether during the contextual shaping passes and put them back in later.
#define STRIP_NUQTAS 0


// TEMPORARY

table(glyph) {AttributeOverride = 1}

gKafMedBeRe = pseudo(postscript("absKehehMed.bere_alt"));
gGafMedBeRe = pseudo(postscript("absGafMed.bere_alt"));


gNoonTah = pseudo(postscript("absNoon"), 0x0768);


gBehMedTaM {exit_tah = point(-500m, 200m)};
c_exit_tah += (gBehMedTaM);

gBehMedSd {exit_sad = point(-200m, 650m)};
gLamIni {exit_lamKaf = point(150m, 500m) };

gGafMed {entr_sad = point(221m, -101m) };
c_entr_sad += (gGafMed);

gGafMedBe_alt {entr_kafAlt = point(250m, 1500m) };
c_entr_kafAlt += (gGafMedBe_alt);

gGafMedSn_alt {entr_kafAlt = point(250m, 1500m) };
c_entr_kafAlt += (gGafMedSn_alt);

gBehIni {exit_kafAlt = point(0m, 617m) };
c_exit_kafAlt += (gBehIni);

gKafIniBeM2_alt {exit_behHighTooth = point(0m, 438m) };  // ####
c_exit_behHighTooth += (gKafIniBeM2_alt);

gBehMedBy {exit_bariyeh = point(0m, 250m) };
c_exit_bariyeh += (gBehMedBy);

gSeenMedBy {exit_bariyeh = point(0m, 250m) };
c_exit_bariyeh += (gSeenMedBy);

gJeemMedBy {exit_bariyeh = point(0m, 250m) };
c_exit_bariyeh += (gJeemMedBy);

gJeemMedHd {exit_hehdoach = point(0m, 250m) };
c_exit_hehdoach += (gJeemMedHd);

gHehDoMedBy {entr_hehdoach = point(950m, 1000m) };
c_entr_hehdoach += (gHehDoMedBy);

gHehDoMedBeRe {entr_hehdoach = point(620m, 900m) };
c_entr_hehdoach += (gHehDoMedBeRe);

gHehDoMedBe {entr_hehdoach = point(500m, 1500m) };   // ####
c_entr_hehdoach += (gHehDoMedBe);



gJeemMedJm { nUpperS = point(213m, 1091m) };
cTakes_nUpperDia += (gJeemMedJm);

gJeemMed { n1LowerS = point(0m, 0m) };
cTakes_n1LowerDia += (gJeemMed);

gJeemFin { nUpperS = point(-0m, 1100m) };

gLamIniJm { mLowerS = point(600m, 1300m) };
cTakes_mLowerDia += (gLamIniJm);

endtable;


// Classes for contextual shaping:
#include "nastaliq_cntxlClasses.gdh"

#include "nastaliq_classes.gdh"


#if DO_COL_FIX

#include "nastaliq_complexShapes.gdh"

table(glyph)

cKernable = (c_isolated c_final) {collision.kern = true};

endtable;

#endif // DO_COL_FIX


// FEATURES

//table(feature)
//endtable; // feature



#define DIACS [cDiacritic cDiacritic?]?

// TODO: include diacritic combinations
#define MARKS  cNuqtaLike?  DIACS

// In positioning table, allow two nuqta-like glyphs for some glyphs that can have
// nuqtas both above and below
#define MARKS2N  cNuqtaLikeLower? cNuqtaLikeUpper?  DIACS


// EXPERIMENTAL - both lower and upper nuqtas

table(glyph)

g_dalTahNuqtas = pseudo(postscript("absDal"), 0x0759);
g_dalTahNuqtasFin = pseudo(postscript("absDalFin"));

g_rehDotBelowDotAbove = pseudo(postscript("absReh"), 0x0696);
g_rehDotBelowDotAboveFin = pseudo(postscript("absRehFin"));

cRightLinkIso += (g_dalTahNuqtas, g_rehDotBelowDotAbove);
cRightLinkFin += (g_dalTahNuqtasFin, g_rehDotBelowDotAboveFin);


cLowerUpper = (g__dot2l_smallTah, g__dot2vl_smallTah, g__dot1l_dot1u);
cLowerNoUpper = (g__dot2l, g__dot2vl, g__dot1l);
cUpperNoLower = (g__smallTah, g__smallTah, g__dot1u);

endtable;


// SUBSTITUTION RULES

#include "nastaliq_shaping.gdh"


// EXPERIMENTAL - both lower and upper nuqtas

table(sub)
pass(2)

////g_gDalTwoVertBelowSmallTahFin	_	>	gDalFin		g__dot2vl_smallTah:1;
g_rehDotBelowDotAboveFin	 	_	>	gRehFin		g__dot1l_dot1u:1;

endpass;

pass(6)

// Break lower-and-upper-nuqta glyphs into two separate glyphs, so they can be positioned separately.

cLowerUpper  _  >  cLowerNoUpper  cUpperNoLower$1:1;

endpass;
endtable;


// POSITIONING RULES

#include "nastaliq_positioning.gdh"