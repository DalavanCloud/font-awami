/*
    File: nastaliq_rules.gdl

    Graphite positioning rules for Awami Nastaliq
*/


table(positioning)

pass(1)

//
//	CURSIVE ATTACHMENT
//

#define cursive_attach(P)  c_exit_##P {att {to=@L; with=exit_##P; at=entr_##P}} c_entr_##P {insert=1} / _ MARKS2N ^ _=L ;

// Only used for beh so we don't need to allow upper and lower diacs:
#define cursive_attach2(P1, P2)  c_exit_##P1 {att {to=@L; with=exit_##P1; at=entr_##P2}} c_entr_##P2 {insert=1} / _ MARKS ^ _=L ;


#if (QUICKCOMPILE == 0)

cursive_attach(alef)
cursive_attach(beh)
cursive_attach(behFinal)
cursive_attach(behHighTooth)
cursive_attach(behLowTooth)
cursive_attach2(behLowTooth, behPreFinalHehGoal)
cursive_attach(behPreReh)
cursive_attach(behPreNoon)
cursive_attach(jeem)
cursive_attach(reh)
cursive_attach(rehHgm)
cursive_attach(rehJkl)
//cursive_attach(rehSshg)
cursive_attach(seen)
cursive_attach(sad)
cursive_attach(tah)
cursive_attach(ain)
cursive_attach(feh)
cursive_attach(meem)
cursive_attach(meemAlt)
cursive_attach(noon)
cursive_attach(hehgoalMedial)
cursive_attach(hehgoalFinal)
cursive_attach(hehdoach)
cursive_attach(chotiyeh)
cursive_attach(chotiyehBfkl)
cursive_attach(bariyeh)
cursive_attach(lamKaf)
cursive_attach(qafWaw)
cursive_attach(qafWawStfh)

//  c_exit_qafWawStfh {  attach {to = @6; with = exit_qafWawStfh; at = entr_qafWawStfh; }  }  c_entr_qafWawStfh { insert = 1;  }  
//              /  _  cNuqtaLikeLower  cNuqtaLikeUpMid  cDiacritic  cDiacritic  ^  _  ;" >


#endif  // QUICKCOMPILE

// EXPERIMENTS
#define SHIFT_N_OUT 0m

// Last resort:
(c_initial c_medial) {att.to=@L} (c_medial  c_final  g_zerojoin) {insert=1}  / _ MARKS2N ^ _=L ;

if (wordSpacing == xtight)
cSpace { advance.x = 50m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == tight)
cSpace { advance.x = 150m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == medium)
cSpace { advance.x = 200m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == wide)
cSpace {advance.x = 250m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == xwide)
cSpace {advance.x = 300m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

endpass; // 1

endtable;	// positioning


// TEMPORARY
table(glyph)

c_initial { zeroS = point(0m, 0m) };
c_medial  { zeroS = point(0m, 0m) };
c_final   { zeroS = point(0m, 0m) };

cNuqtaLike { zeroM = point(0m, 0m); zeroS = point(0m, 0m) };

cDiacritic { zeroM = point(0m, 0m) };

endtable;


//
//  NUQTA POSITIONING
//

table(positioning)

pass(2)

// Use wider spaces for Latin text.
cSpace {advance.x += 200m}  /  _  cLatin;
cSpace {advance.x += 200m}  /  cLatin  _;


// Upper and lower nuqta attachment

table(glyph)

// For some reason I have to subtract something to make these things work. :-/
cn1LowerDia { nByLowerM = point(n1LowerM.x, n1LowerM.y - 1m) };
cn23LowerDia { nByLowerM = point(n23LowerM.x, n23LowerM.y - 1m) };

cTakes_nLowerDia = (cTakes_n1LowerDia cTakes_n23LowerDia);

// For attaching any kind of nuqta-like thing...
cHasUpperMaux = (cNuqtaUpper, gHamzaAbove, g__hamzaArabic, g__smallTah, g__smallTah2dots, g__smallV);
cNuqtaUpper { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };
gHamzaAbove { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__hamzaArabic  { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__smallTah { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallTah2dots { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallV  { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };


// Intersection classes:

cTakes_hamzaAndN23LowerDia = cTakes_n23LowerDia;
cTakes_hamzaAndN23LowerDia &= cTakes_hamzaUpperDia;

cTakes_hamzaAndHehhookDia = cTakes_hamzaUpperDia;
cTakes_hamzaAndHehhookDia &= cTakes_hehhookDia;

cTakes_ringAndNUpperDia = cTakes_nUpperDia;
cTakes_ringAndNUpperDia &= cTakes_ringDia;

endtable;  // glyph


// Special bariyeh rules: move any nuqtas within three chars of a bariyeh down.

// X+NxL  Y+NyL  Z+Nz  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	csMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyU  Z+NzL  Bariyeh
// Here we attach the upper nuqta too, since if we back up to attach it, it will reattach and mess up
// the second lower nuqta.
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	c_medial   cHasUpperMaux   { attach {to = @Y; at = nUpperS; with = nUpperMaux } }
	csMedBy cNuqtaLower       { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyL  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	csMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  c_medial=Y DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyL  Z  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidLeftLowerS; with = nByLowerM } }
	/ _=B1 _=L1 DIACS  _=B2  _=L2  DIACS  ^ csMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;

// X+NxL  Y+NyL  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidRightLowerS; with = nByLowerM } }
	csMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y  _=Ny DIACS  ^ gBariyehFin=By;

// X+Nx Y Bariyeh 
cTakes_nLowerDia  cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	/ _=B _=L  DIACS  ^ csMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;



// Not really needed, because all glyphs with lower diacs can take upper diacs
//table(glyph)
//cTakes_n1Lower_and_nUpperDia = cTakes_n1LowerDia;
//cTakes_n1Lower_and_nUpperDia &= (cTakes_nUpperDia);
//endtable;

// kaf-top, nuqta(s) below
/*
cTakes_kafTopDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	ckafTopDia { attach {to = @K; at = kafTopS; with = kafTopM } }
	/ _=K  _=L  _=T;


cTakes_gafStrokeDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
	/ _=K  _=L  _=S;
*/

// tah above, nuqta(s) below
cTakes_tahUpperDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=L  _=U;
// Do we need this? We shouldn't need to attach a tah to a glyph that doesn't take a tah.
//cTakes_n1LowerDia
//	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
//	ctahUpperDia { attach {to = @B; at = nUpperS; with = tahUpperM } }
//	/ _=B  _=L  _=U;

// nuqtas above, hehhook below
cTakes_hehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// nuqtas above and below
cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// hamza above, nuqtas below
cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
(cBehIni cBehMed)
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;


// Upper nuqta-like attachment


////gJeemFin  cNuqtaLike { attach {to = @J; at = point(574m, 1274m); with = nUpperM} }
////	/  gJeemMedJm=J  cNuqtaLike?  _=J  _=N;

//cTakes_n1hUpperBehSpecialDia
//	cNuqtaLikeUpper { attach {to = @B; at = n1hUpperBehSpecialS; with = nUpperM } }
//	/ _=B  _=U;

// Put hamza rules first to make sure to use hamza APs for them.
cTakes_hamzaAndHehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=H  _=U;

cTakes_hamzaUpperDia
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=U;

cTakes_hamzaLowerDia
	chamzaLowerDia { attach {to = @B; at = hamzaLowerS; with = hamzaLowerM } }
	/ _=B  _=U;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
// TODO: add real hamzaUpper APs to beh forms.
(cBehIni cBehMed)
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=H;

// Bar after kaf needs to be offset vertically.
/*
(cLamMed cLamFin)
	cbarDia { attach {to = @L; at {x = barS.x; y = barS.y + 380m}; with = barM } }
	/ (cKafIni cKafMed)  MARKS  _=L  _=B;
*/

cTakes_barDia
	cbarDia { attach {to = @B; at = barS; with = barM } }
	/ _=B  _=U;

cTakes_squiggleDia
	csquiggleDia { attach {to = @K; at = squiggleS; with = squiggleM } }
	/ _=K  _=S;

////cTakes_gafStrokeDia
////	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
////	/ _=K  _=S;

// Use smallV AP if present, otherwise small-V will attach at nUpper - no longer used.
////cTakes_smallVDia
////	g__smallV { attach {to = @B; at = smallVS; with = nUpperM } }
////	/ _=B  _=U;

cTakes_nUpperDia
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U;

cTakes_tahUpperDia
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=U;

// nuqtas above, ring below
cTakes_ringAndNUpperDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U _=R;

cTakes_ringDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	/ _=B  g__kafTop_null?  _=R;

// Odd situation, but just in case:
c_isolate
	gMaddaAbove { attach {to = @B; at = mUpperS; with = mUpperM } }
	/ _=B  _=M;


// Lower nuqta attachment

cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_tahLowerDia
	ctahLowerDia { attach {to = @B; at = tahLowerS; with = tahLowerM } }
	/ _=B  _=U;

// Hehhook
cTakes_hehhookDia  g__hehHook_small  { attach {to = @B; at = hehhookS; with = hehhookM } }
	/ _=B  _=H;

// Hehhook - big
////////attachR_BN(	gHehGoalIni,	g__hehHook_big,		default2,		default2_)


// TEMPORARY - fall-back attachment
// Needed to test in Graphite1.
(c_initial c_medial c_final)  g__kafTop_null;

(c_initial c_medial c_final)  cNuqtaLike { attach {to = @1; at = zeroS; with = zeroM } };


// Subtending marks

// NB: at this point digits should be in visual order, right to left,
// so we attach the left-most (logically first) to the sign, and proceed to the right.

cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign4=S;

cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign3=S;

cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign2=S;

cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign1=S;

// However, there is a bug in some implementations (eg Firefox) where the numbers are still in
// logical order.

cSign4=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true};
	
cSign3=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true};
	
cSign2=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true};
	
cSign1=S
	cSignDigit { attach {to=@S;  at=digitS; with=digitM }; insert = true};

endpass;  // 2

endtable;  // pos


#if DO_COL_FIX

// Define fake right and left bounding boundaries that will be compared to the side-bearing marks
// and used to determine the ideal margin/kerning.

table(glyph) {AttributeOverride = 0}

// Define for all needed glyphs where they have not been defined in the font.
c_initial {kernBbRightS = point(0m,0m) };
c_final {kernBbLeftS = point(0m,0m) };
c_isolate {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };

cKernPunct = (gComma gFullStop gSemicolon g_colonArab g_exclamArab gQuestionMark)
	{kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };

endtable;


table(glyph)

cPostKernable = (c_initial  c_isolate  cKernPunct) {
	dbgBbRight = bb.right; dbgRsb = rsb; dbgAdv = advancewidth;
	kernRsb = advancewidth - ((kernBbRightS.x == 0) ? bb.right : kernBbRightS.x);
};

cKernable = (c_isolate  c_final  cKernPunct)
{
	dbgBbLeft = bb.left; dbgLsb = lsb;
	kernLsb = ((kernBbLeftS.x == 0) ? bb.left : kernBbLeftS.x);
}

c_jumpTail = ( cJeemFin, gAinFin );


cls_excludingGlyphs = (cKafMed csKafMed_base)
	{collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

cls_excludingGlyphs_kern = (gKafFin, gGafFin)
	{collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

endtable;


// Nuqta collision fixing

table(positioning)

if (collFix > 0)

pass(3)

// Set up for collision fixing

#define MAXKERN 5000m
#define MINKERN -700m
#define MINKERN_TIGHT -3000m
#define MINKERN_WIDE -200m
#define STDMARGIN 150m
#define STDMARGINWT 400
#define STDMARGIN_N1 150m
#define STDMARGINWT_N1 200
#define STDMARGIN_N2 150m
#define STDMARGINWT_N2 200
#define STDMARGIN_DIAC 200m
#define STDMARGINWT_DIAC 400

#define KERNMARGIN_TIGHT 150m
#define KERNMARGIN_MED 300m
#define KERNMARGIN_WIDE 400m


#define ORDER_UNUQTAS 1
#define ORDER_LNUQTAS 2
#define ORDER_LNUQTAS_SUB_BYEH 3

#define ORDER_UDIACS 4
#define ORDER_LDIACS 5

table(glyph) {AttributeOverride = 1}

cNuqtaLikeUpper {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_UNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 50 };
		valign { height = 275m;	weight = 500 }
	}
};

gHighHamza { sequence.class = 0 };

cNuqtaLikeLower {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_LNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 500 }; // weight was 50
		valign { height = 275m;	weight = 500 }
	}
};

g__bar { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };
g__attachedRing { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };

cgafStrokeDia { collision { margin = 0; flags = 0 }; sequence { class = 0; order = 0 } };


// Smaller nuqta glyphs need larger margins:
g__dot1u { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };
g__dot1l { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };
g__dot2u { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };
g__dot2l { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };


cDiacriticUpper {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; } - set in the rule
};

gNoonGhunnaMark { collision.margin = 300m; marginweight = 300 }; // override

cBase = (c_isolate, c_initial, c_medial, c_final, g_zerojoin);

cDiacriticLower {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; } - set in the rule
};

//cNuqtaLikeAbove { collision.order { class = ORDER_UNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };
//cNuqtaLikeBelow { collision.order { class = ORDER_LNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };

endtable; // glyph


// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags); collision.flags = SET_IGNORE(collision.flags) };


g__kafTop_null { collision {flags = COLL_FREEZE} }  /  cBase  _ ;   // make context long enough to give precedence


// Upper nuqtas

// Gaf strokes are considered part of the base - they don't move.
cgafStrokeDia { collision.flags = COLL_FREEZE }  /  cBase  _ ;     // make context long enough to give precedence

// Things on top of alefs should never move horizontally. For now, just don't let them move at all.
// Also, don't force preceding nuqta-like things to move above them.
cNuqtaLikeUpper { collision.flags = COLL_FREEZE; sequence.class = 0 }  /  (gAlef cAlefFin)  _;


// Small V over lam needs to stay nicely centered.
g__smallV { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 50m;
	min.y = -300m;
	max.y = 1000m;
} }  /  (cLamIni cLamMed)  _;

	
// Special case: if there is a nuqta before a zah, scootch the nuqta of the
// zah down pretty close to the base.
/**
cNuqtaLikeUpper { 
	shift { x = 50m; y = -150m }; // note that shifting in RTL moves forward, ie, left.
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 100m;
		min.y = -100m;
		max.y = 300m;
	}
} /  cNuqtaLikeUpper=N1 DIACS  cTahMed  _=N2 ;
**/


// The nuqta on the zah (tah form) fits nicely above it, so it is not normally helpful to move it.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;   // don't let this one move left much
	max.x = 100m;
	min.y = -200m;  // shouldn't need to move vertically either, at least by much
	max.y = 300m;
} } / cTahMed _ ;


// Exception to special case below when there is a previous lam/kaf.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } / (cLamIM cKafIM) cDiacritic?  cBase  _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);

// Special case involving jeem + beh/seen - don't allow it to move right
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 100m;  // less than normal
	min.y = -300m;
	max.y = 1000m;
} } / cJeemIM  cNuqtaLike?  cDiacritic?  (cBehMed cSeenMed)  _  ;

// Special cases involving kaf tops - allow nuqtas to move further right than normal.
// Remove for now - this is too extreme.
/***
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 800m; // a lot more than normal
	min.y = -300m;
	max.y = 1000m;
} } / _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);
***/


// Special case: jeem + teh/theh - allow more movement to get the nuqta on the jeem to the right of the nuqta on the beh form.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m;
	min.y = -300m;
	max.y = 1000m;
} } / cJeemIM _ cDiacritic? cBehMed cNuqtaLikeUpper;


// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m; // more than normal
	min.y = -300m;
	max.y = 1000m;
} } / c_initial _;

// Nuqtas on finals can be moved quite a bit to the left.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -500m;   // more than normal
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } / c_final _;

/*** Special case: jeem followed by nuqta
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	margin = 250m;
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} }  /  cJeemIni  cNuqtaLike?  cBase  _; 
***/

// Default case: nuqtas above (other than initial) can move more to the left than the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} };


// Middle nuqta-like stuff: bars and rings
// Ideally it would be nice to be able to move the bars up and down a little to avoid
// collisions, but to do that we would need to be able to ignore the base (lam) from
// the perspective of the bar.

g__bar { collision.flags = COLL_FREEZE }    /  cBase  _ ;  // add context to increase precedence
g__attachedRing { collision.flags = COLL_FREEZE }  /  cBase  _ ;

// Lower nuqtas

// Nuqtas before certain finals can move down quite a bit to jump below swashes.
// Note that if we make the lower limit too low, the nuqtas will jump completely *below* 
// the swash, which is not what we want. We want to be down and to the right.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 700m;	// a lot!
		min.y = -1600m; // a lot!
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / _  c_jumpTail;

// Gueh vertical dots must stay close to the kaf stem.
g__dot2vl {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 150m;
		min.y = -1000m;
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / cKafIM  g__kafTop_null  _=N;


// Nuqtas below a bariyeh cannot move up, shouldn't need to move down, and they don't flow diagonally.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -400m;
		max.x = 400m;
		min.y = -20m;
		max.y = 0m;
  };
  sequence { class = 0; order = 0 }
} / c_initial?  _ {underBy == true};


// Heh-hooks need to be kept centered under the base.
g__hehHook_small { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 50m;
	min.y = -1000m;
	max.y = 50m;
} };

// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 400m;  // 600 breaks \u067E\u0650\u06CC\u064F\u0648
	min.y = -1000m;
	max.y = 300m;
} }  /  c_initial  _;

// Default case: nuqtas below (other than initial) can move more to the right than the left.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 350m;   // making this 400 helps \u067E\u0650\u06CC\u0686\u06BE\u06D2 but breaks other things
	min.y = -1000m;
	max.y = 300m;
} };

// Exclusion glyphs for space above kafs and gafs

// For ngoeh, don't using the exclusion glyph - the nuqtas need to go right on top of the gaf.
(cls_excludingGlyphs cls_excludingGlyphs_kern) { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
} } / _  g__kafTop_null? g__dot2u;

cls_excludingGlyphs { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} };

cls_excludingGlyphs_kern { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	max.x = MAXKERN; min.x = MINKERN;
	margin = 100m;
    // min/max.y are omitted for kernable glyphs
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} };


// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.
// We actually set the kerning parameters in the final pass. But here, at least indicate
// which glyphs can be kerned, which affects how shifting works around them.

cKernable { collision {
	//---flags = SET_FIX(collision.flags); -- move actual kerning to end of process
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	////max.x = 300m; min.x = 0;  // kerning right is logically equivalent to shifting left in RTL
	//---max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


// Other bases are not moved.
(c_initial c_medial) { collision { flags = COLL_FREEZE } };

cDiacritic { collision.flags = SET_IGNORE(collision.flags) };	// these have not been attached, so don't bother with them

(g_quotedblright g_quotedblrightArab) { collision.flags = SET_IGNORE(collision.flags) }; // fix with kerning

endpass; // 3

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.
if (collFix > 1)
pass(4) { CollisionFix = 5 }
// Perform base + nuqta collision fixing. Any failures leave for now.
endpass;
endif;

/**************************************

#define CHARSEQ cMed cNuqtaLike? cDiacritic?
#define SEQ2 [[CHARSEQ]? CHARSEQ]?
#define SEQ3 [[[CHARSEQ]? CHARSEQ]? CHARSEQ]?
#define YBELOWBYEH -450

if (collFix > 1)
pass(4) { CollisionFix = 4 }

// Next: adjust for nuqtas moved below a bariyeh.
// Needed for, eg, \u0686\u067E\u0679\u06CC\u0646\u06D2

cNuqtaLikeLower {
	collision.max.y = 0m; // ideally this would be set to what it is shifted by already
	sequence { class = ORDER_LNUQTAS_SUB_BYEH; order = 0 }
}  / (c_medial c_initial)  _ {position.y < 0}  cDiacritic?  SEQ2 gBariyehFin;

// Nuqtas still above a bariyeh need more flexibility; if they are initial, let them move right:
cNuqtaLikeLower {
	collision.max.x = 750m;
	sequence.class = 0;
}  / cIni  _ {position.y > 100m}  cDiacritic?  SEQ2 gBariyehFin;


endpass;  // 4
endif;    // collFix > 1

*****************************************/

endtable;

#endif // DO_COL_FIX

/*****  Not needed - the collision-fix pass sets all the positions accurately.
table(glyph)
cNonBaseTemp = (cNuqtaLike  g__kafTop_null)
endtable;

#define NOTSET 12345  // some number that is not likely to be a real value

c_initial {user6 = position.y}  c_final {user6 = position.y}   / _=I  MARKS2N  _=F;
c_initial {user6 = position.y}  c_medial {user6 = position.y}  c_final {user6 = position.y} / _=I MARKS2N  _=M MARKS2N _=F;

c_medial {user6 = NOTSET}  c_medial {user6 = position.y}   c_final {user6 = NOTSET}
	/ ^ cIniMed cNonBaseTemp?  _=M1  cNonBaseTemp?  _=M2 cNonBaseTemp?  _=F {user6==0};

c_medial {user6 = NOTSET}  c_medial {user6 = position.y}
	/ ^ cIniMed MARKS2N  _=M1 MARKS2N  _=M2 {user6 == NOTSET};

c_initial {user6 = position.y}  c_medial {user6 = position.y}  /  _=I  MARKS2N  _=M {user6==NOTSET} ;

// Do this last:
c_final {user6 = position.y}  /  _ {user6 == NOTSET};
*****/


#define pairKern user2
#define tooHigh user3

// currently not used
////#define marginSet user4  -- currently not used


table(positioning)

//
//	KAF HEIGHT ADJUSTMENTS
//

table(glyph)

cNuqtaLikeUpperNoKT = (cNuqtaLikeUpper);
cNuqtaLikeUpperNoKT -= (g__kafTop_null);

c_narrow = (gBehMed gMeemMed gAinMed);

endtable;

// Since the last positioning pass does not block the area above the kaf, limit the movement
// of nuqta behind/under a kaf.
#define STAYBELOWKAF {collision {min.x = 0m; max.y = 300m}}

pass(5)

// Kaf-top collision fixing/prevention and tall sequences

// Tall: large-nuqta + kaf 
cNuqtaUpperLarge  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N  cDiacritic?  _=K  _=T;

// Tall: lam/tah + kaf
// TODO: move cBaseTall back into context
cBaseTall  csKafMed_medium  g__kafTop_null  
	>  @B1  csKafMed_base$K  csKafMed_top_tall$K
	/  _=B1  MARKS  _=K  _=T;

cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF csKafMed_base$K  csKafMed_top_tall$K
	/  _=N cBaseTall  MARKS  _=K  _=T;

// Tall: nuqta + diac + kaf
cNuqtaLike  csKafMed_medium  g__kafTop_null  
	>  @N STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N  cDiacriticUpper  _=K  _=T;

// Don't change: single-nuqta + single-nuqta + kaf (eg, \u0628\u0650\u0646\u0650\u0646\u06AF\u064E\u06A9\u06C1)
g__dot1u  g__dot1u  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  @K  @T
	/  _=N1  cDiacritic?  c_medial  _=N2  cDiacritic? ^ _=K  _=T;

// Tall: nuqta + nuqta + kaf (eg, sheen + teh + kaf)
cNuqtaLikeUpperNoKT  cNuqtaLikeUpper  csKafMed_medium  g__kafTop_null  
	>  @N1  @N2 STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  _=N1  cDiacritic?  c_medial  _=N2  cDiacritic?  _=K  _=T;

// nuqta + diac + kaf => default
csKafMed_medium  g__kafTop_null  >  @K  @T
	/  cNuqtaUpperSmall  cDiacritic  _=K  _=T;

// Short + medium-short: gaf + ??? + kaf/gaf
csGafIM_medium g__kafTop_null  cNuqtaLikeUpper  csKafMed_medium g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  
			@Nfb STAYBELOWKAF // keep nuqta from hopping above kaf
			csKafMed_base$K  csKafMed_top_medshort$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) _=Nfb cDiacritic? _=K _=Tk;

csGafIM_medium g__kafTop_null  csKafMed_medium g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  csKafMed_base$K  csKafMed_top_medshort$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) cNuqtaLike? cDiacritic? _=K _=Tk;


// Gaf + kaf/gaf-medial => shorter
csGafIM_medium  g__kafTop_null  csKafMed_medium  g__kafTop_null
	>  csGafIM_base$G  csGafIM_top_shorter$G  csKafMed_base$K  csKafMed_top_tall$K
	/  _=G _=Tg  cNuqtaLike?  cDiacritic?  _=K _=Tk;

// Gaf + kaf/gaf-final => short
csGafIM_medium g__kafTop_null  (gKafFin gGafFin)
	>  csGafIM_base$G  csGafIM_top_short$G  @K
	/  _=G _=Tg  cNuqtaLike? cDiacritic? _=K;

// Medium-short: lam/tah + jeem + kaf
cBaseTall  csKafMed_medium  g__kafTop_null  
	>  @B  csKafMed_base$K  csKafMed_top_medshort$K
	/  _=B  cNuqtaLike? cDiacritic?  cJeemMed  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Medium-short: tah + beh/meem/ain + kaf...
cTahIM  csKafMed_medium  g__kafTop_null  
	>  @Ta  csKafMed_base$K  csKafMed_top_medshort$K
	/  _=Ta cNuqtaLike? cDiacritic?  c_narrow cNuqtaLike? cDiacritic?  _=K  _=T;

// Medium-short: nuqta + jeem + kaf...
cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null  
	>  @N {shift.x = -300m; collision {max.x = 600m; max.y = 200m}} // move right, not up
			csKafMed_base$K  csKafMed_top_medshort$K
	/  _=N  cDiacritic?  cJeemMed  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Short round form: tah + kaf + lam/alef
cTahIM  csKafRound_medium  g__kafTop_null
	>  @Ta  csKafRound_short  @Null
	/  _=Ta MARKS  _=K MARKS  _=Null;

// No change (\u062C\u0646\u06AF\u06CC)
g__dot1u  csKafMed_medium  g__kafTop_null
	>  @N STAYBELOWKAF  @K  @T
	/  cJeemIM  cNuqtaLike?  cDiacritic?  c_medial  _=N  cDiacritic?  _=K  _=T;

// Tall (\u062E\u064F\u0634\u06A9\u06CC)
cNuqtaLikeUpperNoKT  csKafMed_medium  g__kafTop_null
	>  @N STAYBELOWKAF  csKafMed_base$K  csKafMed_top_tall$K
	/  cJeemIM  cNuqtaLike?  cDiacritic?  c_medial  _=N  cDiacritic?  _=K  _=T;


// Situations where short kaf is needed due to height (except cases above)

cNuqtaLikeUpper?  cDiacritic?  csKafIM_medium  g__kafTop_null
	>	@N STAYBELOWKAF  @D  csKafIM_base$K  csKafIM_top_shorter$K
	/  _=N  _=D  _=K {position.y > 1350m}  _=T;


cNuqtaLikeUpper?  cDiacritic?  csKafIM_medium  g__kafTop_null
	>	@N STAYBELOWKAF  @D  csKafIM_base$K  csKafIM_top_short$K
	/  _=N  _=D  _=K {position.y > 1135m}  _=T;


// If a nuqta is up above the line, move it down and let the collision fixing algorithm pop it
// back up if necessary.
cNuqtaLikeUpper { shift.y = -300m; collision.margin -= 50m } / _ { position.y > 2800m };
// Similarly for tall nuqtas below the line, if they also have a diacritic under them.
cNuqtaLikeLowerTall { shift.y = 100m; collision.flags = CLEAR_FIX(collision.flags) }
	/ _ { position.y < -550m } cNuqtaLikeUpper? cDiacriticLower;


// If a nuqta is not near a height-adjusted kaf, turn off collision fixing for next time around.
// Note that this also turns it off for g__kafTop_null, which is fine (although it should already be off).
cNuqtaLike { collision.flags = CLEAR_FIX(collision.flags) };

// Debugging:
c_initial {user5 = bb.top; user6 = position.y + bb.top};


endpass;  // pass 5


table(glyph)
csFinal_regular = (gSeenFin, gChotiyehFin, gNoonFin);
csFinal_short = (gSeenFin_short, gChotiyehFin_short, gNoonFin_short);
endtable;

if (shortFinals == 1)
pass(6)

c_initial     c_medial  >  @I  @M {tooHigh = 1}   /  _=I  {position.y + bb.top > 2000m}  cNuqtaLikeUpper  cDiacriticUpper ^ _=M;
c_initial     c_medial  >  @I  @M {tooHigh = 1}   
	/  _=I  {position.y + bb.top > 2500m}  cNuqtaLikeLower? (cNuqtaLikeUpper  cDiacriticUpper) cDiacriticLower? ^ _=M;
c_initial     c_medial  >  @I  @M {tooHigh = 1}   /  _=I  {position.y + bb.top > 3000m}  MARKS ^ _=M;

csKafIM_base  c_medial  >  @I  @M {tooHigh = 1}   /  _=I  {tooHigh == 1 || position.y > 1400m}  MARKS ^ _=M;

c_medial      c_medial  >  @M1 @M2 {tooHigh = 1}  /  _=M1 {tooHigh == 1}  MARKS ^ _=M2;

c_medial  csFinal_regular  >  @M  csFinal_short   /  _=M  {tooHigh == 1}  MARKS  _=F;

endpass;  // 6
endif;


pass(7)

// Due to an infelicity in the Graphite engine, we can't substitute and attach in the same rule,
// so we have to do it in a separate pass.

// ngoeh nuqtas
csKafIM_base=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true}
	cNuqtaUpper { shift.x = @T.nDelta;  collision.flags = SET_FIX(collision.flags) };
csKafIM_base=B  cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM}; passKeySlot = true}
	cNuqtaUpper { shift.x = @T.nDelta;  collision.flags = SET_FIX(collision.flags) };

// rings
csKafIM_base=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}}
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM }; passKeySlot = true };
csKafIM_base=B  cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM}}
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM }; passKeySlot = true };

csKafIM_base=B  ckafTop_bjDia {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}; passKeySlot = true};
csKafIM_base=B  cKaf_top      {att {to=@B; at=kafTopS;    with=kafTopM}; passKeySlot = true};


c_exit_chotiyeh {att {to=@F; with=exit_chotiyeh; at=entr_chotiyeh}}	gChotiyehFin_short {passKeySlot = true; insert = 1}	/  _ MARKS2N ^ _=F;

c_exit_seen     {att {to=@F; with=exit_seen;     at=entr_seen}}     gSeenFin_short {passKeySlot = true; insert = 1}     /  _ MARKS2N ^ _=F;
c_exit_noon     {att {to=@F; with=exit_noon;     at=entr_noon}}     gNoonFin_short {passKeySlot = true; insert = 1}     /  _ MARKS2N ^ _=F;

csFinal_short  chamzaUpperDia {att {to=@F; at=hamzaUpperS; with=hamzaUpperM}} / _=F  _;
csFinal_short  ctahUpperDia   {att {to=@F; at=tahUpperS; with=tahUpperM}}     / _=F  _;
csFinal_short
	cn23LowerDia {att {to=@F; at=n23LowerS; with=n23LowerM}; collision.flags = SET_FIX(collision.flags)}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
csFinal_short
	cNuqtaLikeLower {att {to=@F; at=n1LowerS; with=n1LowerM}}
	cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}
	/ _=F  _  _;
csFinal_short  cNuqtaLikeUpper {att {to=@F; at=nUpperS; with=nUpperM}}  / _=F  _;

endpass;


//
//	DIACRITIC ATTACHMENT
//


// Order of glyphs: base, nuqta below, nuqta above, diacritics below, diacritics above
// But if an upper diacritic is in a "closer" mark class (eg, cMark1), it can come before the lower diacritic.

#if DO_COL_FIX
pass(8)
#else
pass(4)
#endif // DO_COL_FIX


// Attach diacritics
 
table(glyph) { AttributeOverride = false }
// Classes of nuqtas and things that attach closely like nuqtas.
// These are basically defined for the purpose of ignoring in the context of attaching
// diacritics to things.
c_attLikeNqUpper = (cNuqtaLikeUpper); // includes small tah
c_attLikeNqLower = (cNuqtaLikeLower, g__hehHook_small);
c_attLikeNqLowMid = (c_attLikeNqLower, cNuqtaLikeMiddle,
	g__kafTop_null); // diacs don't attach to this, so attach to the base even if this is there
c_attLikeNqUpMid = (c_attLikeNqUpper, cNuqtaLikeMiddle);
endtable;


/****
// Alternate approach to honorifics with diacritics - attach them to the diacritic:
table(glyph)
gZabar { honorificS = point(-200m, 300m) };
gPesh { honorificS = point(-200m, 300m) };
endtable;

cDiacriticUpper=D  chonorificDia=H {att {to=@D; at=honorificS; with=honorificM}; insert=true}
		/ ^ _  _ {att.to==0};
****/


// diacritic AND honorific attached to final base or its nuqta;
// honorific is positioned off to the left
cIsoFin=B  cNuqtaLikeUpper=N
	cDiacriticUpper=D {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^  _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

cIsoFin=B  
	cDiacriticUpper=D {att {to=@B; at=mUpperS; with=mUpperM}; insert=true}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

// honorific attached to final beh with lower nuqtas, w/o upper diac - 
// uses standard upper nuqta location raised a little higher
cBehFin=B  chonorificDia=H {att {to=@B; at {x=nUpperS.x; y=nUpperS.y + 300m}; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};


// Nuqta + upper and lower diacritic
// Eg, noon-nuqta + noon-ghunna-mark + zair (\u0646\u0658\u0650)
cTakes_nUpperDia=B  cNuqtaUpper=N
	cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}}
	cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}}; 


// attach to nuqta
cTakes_mUpperDia  c_attLikeNqUpper=N  cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower? _=D {att.to==0};
cTakes_mLowerDia  c_attLikeNqLower=N  cDiacriticLower {att {to=@N; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _=B  _=N  c_attLikeNqUpMid?  _=D {att.to==0};


// Special contextual cases - eg, kaf/lam followed by tailed final 
cTakes_mLowerCDia=B  cDiacriticLower {att {to=@B; at=mLowerCS; with=mLowerM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0}  (gAinFin gChotiyehFin gChotiyehFin_bfkl gJeemFin);

// Only a few glyphs attach the small alef at a special place.
cTakes_alefDia=B  gKharizabar {att {to=@B; at=alefS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Attaching to final form, or nuqta, uses mUpper/LowerS.
cTakes_mUpperDia=B  cDiacriticUpper {att {to=@B; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_mLowerDia=B  cDiacriticLower {att {to=@B; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Taller or shorter kafs - attach to top, not base
cTakes_nUpperDia  cKafTopAdjusted  cDiacriticUpper {att {to=@T; at=nUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  _=T  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};

// Attaching to initial/medial base - uses stationary nuqta APs.
cTakes_nUpperDia=B  cDiacriticUpper {att {to=@B; at=nUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  g__kafTop_null?  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_n1LowerDia=B  cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}; insert=true}
		/ ^ _=B  cKafTop?  c_attLikeNqUpMid?  _=D {att.to==0};

// attach to diacritic
cDiacriticUpper=D1  cDiacriticUpper {att {to=@D1; at=mUpperS; with=mUpperM}; insert=true}
	/ _=D1 ^ _=D2 {att.to==0};
cDiacriticLower=D1  cDiacriticLower {att {to=@D1; at=mLowerS; with=mLowerM}; insert=true}
	/ _=D1 ^ _=D2 {att.to==0};

// Remove if we create a nuqta+smalltah glyph:
////c_attLikeNqUpper=N  g__smallTah=T {att {to=@N; at=mUpperS; with=mUpperM} };


endpass; // pos - 8 (or 4)


// Kerning pair adjustments

table(glyph) { AttributeOverride = 1 }

// alef, dal, reh, reh-sshg, reh-jkl, reh-???, waw, heh-goal, noon

cKernable { kernPreAlef = 0m; kernPreDal = 0m; kernPreReh = 0m; kernPreWaw = 0m;
	kernPreLamAlef = 0m; kernPreKafNoSp = 0m; kernPreShort = 0m;  // kernPreInitial = 0m };
	minKernDelta = 0m };

gDal		{ kernPreAlef = -60m };
gDalFin		{ kernPreAlef = -50m };
gReh		{ kernPreAlef = -120m; kernPreDal = -30m; kernPreReh = -30m; kernPreWaw = -30m; kernPreLamAlef = -30m;
				// Before a two-letter sequence:
				kernPreShort = 80m };
gRehFin_jkl	{ kernPreAlef = -70m };
gWaw		{ kernPreAlef = -80m };

gRehFin		{ minKernDelta = -400m };
gRehFin_jkl	{ minKernDelta = -400m };
//gRehFin_sshg { minKernDelta = -400m }; -- obsolete
gRehFin_hgM { minKernDelta = -400m };

// Don't let punctuation kern underneath following segment:
cKernPunct { minKernDelta = MINKERN * -1 };

// To account for the fact that the top edge of the kaf pushes the top of the alef away:
gAlef { kernPreKafNoSp = -150m };
gAlefFin { kernPreKafNoSp = -80m };

endtable; // glyph


pass(9)

// Special cases involving nuqtas.

table(glyph)
cNlWide = (g__dot2l  g__dot3l  g__dot4l);
cDRW_IF = (cDalIso cDalFin cRehIso gRehFin_jkl cWawIso cWawFin);
cRehFin_longtail = (gRehFin, gRehFin_hgM);
endtable;

// \u0631\u06CC\u0631, \u0634\u0632\u062F\u06CC\u0648
cDRW_IF  (gBehIniRe gBehIniQf)  cNuqtaLikeLower {shift {x = 170m; y = -400m}}  (gRehFin_jkl cWawFin)
	/  _=DR cDiacritic? _=B _=N cDiacritic?  _=RW;

// \u063A\u0632\u06CC\u0631; see also pass below where the margin for the reh is reduced
cRehFin_longtail {collision.margin=30m}  (gBehIniRe gBehIniQf)  cNuqtaLikeLower {shift {x = -80m; y = 150m}}  (gRehFin_jkl cWawFin)
	/  _=R cNuqtaLike? cDiacritic?  _=B _=N cDiacritic?  _=RW;

// \u0627\u06CC\u0645\u0627
gAlef  gBehIniMmX  cNlWide {shift {x = 300m; y = -650m}}  gMeemMed_alt  gAlefFin;

// \u06af\u064f\u06af
csKafIM_base  cKafTop  cDiacriticUpper {shift {x = -800m; y = 100m}} (cKafIM csKafIM_base cKafFin);


// Low priority special case:
////gRehFin {collision.margin = 50m; marginSet = 1}  gBehIniFe  cNlWide; /// {shift {x = 150m; y = 70m}; collision.margin = 50m};


// Set up kerning pairs.

cKernable { pairKern = kernPreAlef }  /  _ ^ MARKS  cNoJoin? (cAlefIso);
cKernable { pairKern = kernPreDal  }  /  _ ^ MARKS  cNoJoin? (cDalIso);
cKernable { pairKern = kernPreReh  }  /  _ ^ MARKS  cNoJoin? (cRehIso);
cKernable { pairKern = kernPreWaw  }  /  _ ^ MARKS  cNoJoin? (cWawIso);
cKernable { pairKern = kernPreLamAlef} / _ ^ MARKS  cNoJoin? (gLamAlef gLamIniAl);

cKernable { pairKern = kernPreKafNoSp }   /  _ ^ MARKS  (gKaf  gGaf  cKafIni);

// Before a two-letter sequence:
cKernable { pairKern = kernPreShort } / _ ^ MARKS  cNoJoin?  c_initial MARKS  c_final;


// Bogus rule that will never fire (for if we disable this pass for debugging):
///////////////gRrehFin_jkl cDiacritic cDiacritic cDiacritic { user4 = 10 };

// Diacritics that extend above/below the line
cDiacriticUpper { shift.y = -350m; collision.margin -= 70m }  /  _ { position.y > 2800m };
cDiacriticLower { shift.y = 150m; collision.margin -= 70m }  /  _ { position.y < -1200m };

endpass;  // 9


#if DO_COL_FIX

// Diacritic collision fixing and kerning

if (collFix > 0)

pass(10) // { CollisionFix = 4; AutoKern = true }


// Set up diacritic collision fixes and kerning.

// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags) };  /// collision.flags = SET_IGNORE(collision.flags) };

// Kaf exclusion glyphs don't affect diacritics.
(cls_excludingGlyphs cls_excludingGlyphs_kern) { collision.exclude.glyph = 0 };

// Undo kludge above
(g_quotedblright g_quotedblrightArab) { collision.flags = CLEAR_IGNORE(collision.flags) };


cKafTop { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = CLEAR_FIX(collision.flags);
	};
	sequence.class = 0
};


if (collFix >= 2)

// For special cases:
////cKernable {collision {
////	flags = SET_FIX(collision.flags);
////	max.x = MAXKERN; min.x = MINKERN + minKernDelta;}}
////	/  _ {marginSet == 1}  cNuqtaLike?  DIACS  cPostKernable;

// Special cases
/**
cDiacriticUpper { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	// Don't set sequence attributes; let the diac stay below the upper nuqta.
}  /  cFehIni  cNuqtaLikeUpper  (cHehGoalMed cMeemMed)  cNuqtaLikeLower?  _;
**/

gNameMarker  { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -400m;
	max.x = 400m;
	min.y = -300m;
	max.y = 800m;
} };

chonorificDia { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	margin = 300m; marginweight = 500; // don't squeeze these in!
	min.x = -250m;
	max.x = 0m;
	min.y = -50m;
	max.y = 500m;
} };

// Diacritics attached to finals - move more to the left
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -400m;  // normally -250
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  c_final  cNuqtaLikeLower?  _;

// Diacritics attached to bases:
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  cBase  cNuqtaLikeLower?  _;


cDiacriticLower { 
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -300m; // making this larger than ideal fixes \u0628\u0650\u06CC\u062C
		max.x = 300m;
		min.y = -1200m; // needed to get below nuqtas for sure; eg \u062A\u0648\u0641\u0650\u06CC\u0642
		max.y = 300m;
	};
	sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; }
}  /  cBase  cNuqtaLikeUpper?  _;

// These should always stay centered over the nuqta if any:
(gNoonGhunnaMark g__smallV) { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -1m;
	max.x = 1m;
	min.y = -300m;
	max.y = 500m;
} }  /  cNuqta  cDiacritic?  _;

cDiacriticUpper { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 250m;
	min.y = -300m;
	max.y = 500m;
} };


cDiacriticLower { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -300m; // making these larger than ideal fixes \u0628\u0650\u06CC\u062C
	max.x = 300m;
	min.y = -800m;
	max.y = 300m;
} };

endif; // (collfix >= 2) - shift fixes


// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.

/******
if (overlapKern == none)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = 0;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == wide)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
//	max.x = MAXKERN; min.x = MINKERN_TIGHT; margin = KERNMARGIN_MED;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == medium)
******/


// Don't let a single-letter word kern underneath following segment:
cIso { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
	max.x = MAXKERN; min.x = (@S.advance.x * -1) - collision.margin;
    // min/max.y are omitted for kernable glyphs
} }
	/  cSpace  _  cNuqtaLike?  DIACS  cSpace=S  cPostKernable=N;

// EXPERIMENT - don't allow ANY overlap between words
//cKernable { collision {
//	flags = SET_FIX(collision.flags);
//	flags = SET_KERN(collision.flags);
//	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
//	max.x = MAXKERN; min.x = (@S.advance.x * -1) - collision.margin;
//    // min/max.y are omitted for kernable glyphs
//} }
//	/  _  cNuqtaLike?  DIACS  cSpace=S  cPostKernable=N;

// For short sequences (two base chars) ending with bariyeh,
// kern against the bariyeh tail, not the initial.

// Special case; also see previous pass where nuqtas are shifted up
cRehFin_longtail { collision {
 	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = 50m;
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _=R  cNuqtaLike? cDiacritic?  (gBehIniRe gBehIniQf)  cNuqtaLikeLower cDiacritic? (gRehFin_jkl cWawFin);



cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0, kernLsb + 90m);  // 90m = bariyeh's rsb
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cNoJoin?  c_initial cNuqtaLike? DIACS [c_medial cNuqtaLike? DIACS]? 
		gBariyehFin=F;

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cNoJoin?  cPostKernable=N;

(cKernable g_quotedblright) { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


/******
endif; // overlapKern == medium

if (overlapKern == tight)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN_TIGHT;
    // min/max.y are omitted for kernable glyphs
} };

endif;
******/

cls_excludingGlyphs { collision { flags = CLEAR_FIX(collision.flags); exclude.glyph = 0 }};

// Note that most nuqtas will have been previously marked not-fix, unless they are contiguous to
// height-adjusted kafs.

/////cKernable { collision.flags = CLEAR_FIX(collision.flags) }; - if kerning is done earlier

endpass;  // pass 10

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.

if (collFix > 0)
pass(11) { CollisionFix = 4; AutoKern = true }
// Perform diacritic-related fixing.
endpass;
endif;

#endif // DO_COL_FIX


/////#include "awami_tweaks.gdh"

endtable;

