/*
    File: nastaliq_rules.gdl

    Graphite positioning rules for Awami Nastaliq
*/


table(positioning)

pass(1)

//
//	CURSIVE ATTACHMENT
//

#define cursive_attach(P)  c_exit_##P {att {to=@L; with=exit_##P; at=entr_##P}} c_entr_##P {insert=1} / _ MARKS2N ^ _=L ;

// Only used for beh so we don't need to allow upper and lower diacs:
#define cursive_attach2(P1, P2)  c_exit_##P1 {att {to=@L; with=exit_##P1; at=entr_##P2}} c_entr_##P2 {insert=1} / _ MARKS ^ _=L ;


#if (QUICKCOMPILE == 0)

cursive_attach(alef)
cursive_attach(beh)
cursive_attach(behFinal)
cursive_attach(behHighTooth)
cursive_attach(behLowTooth)
cursive_attach2(behLowTooth, behPreFinalHehGoal)
cursive_attach(behPreReh)
cursive_attach(behPreNoon)
cursive_attach(jeem)
cursive_attach(reh)
cursive_attach(rehHgm)
cursive_attach(rehJkl)
//cursive_attach(rehSshg)
cursive_attach(seen)
cursive_attach(sad)
cursive_attach(tah)
cursive_attach(ain)
cursive_attach(feh)
cursive_attach(meem)
cursive_attach(meemAlt)
cursive_attach(noon)
cursive_attach(hehgoalMedial)
cursive_attach(hehgoalFinal)
cursive_attach(hehdoach)
cursive_attach(chotiyeh)
cursive_attach(chotiyehBfkl)
cursive_attach(bariyeh)
cursive_attach(lamKaf)
cursive_attach(kafAlt)
cursive_attach(qafWaw)
cursive_attach(qafWawStfh)

//  c_exit_qafWawStfh {  attach {to = @6; with = exit_qafWawStfh; at = entr_qafWawStfh; }  }  c_entr_qafWawStfh { insert = 1;  }  
//              /  _  cNuqtaLikeLower  cNuqtaLikeUpMid  cDiacritic  cDiacritic  ^  _  ;" >


#endif  // QUICKCOMPILE

// EXPERIMENTS
#define SHIFT_N_OUT 0m

// Last resort:
(c_initial c_medial) {att.to=@L} (c_medial  c_final  g_zerojoin) {insert=1}  / _ MARKS2N ^ _=L ;

if (wordSpacing == xtight)
cSpace { advance.x = 50m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == tight)
cSpace { advance.x = 150m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == medium)
cSpace { advance.x = 200m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == wide)
cSpace {advance.x = 250m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

if (wordSpacing == xwide)
cSpace {advance.x = 300m; collision.flags = SET_ISSPACE(collision.flags) };
endif;

endpass; // 1

endtable;	// positioning


// TEMPORARY
table(glyph)

c_initial { zeroS = point(0m, 0m) };
c_medial  { zeroS = point(0m, 0m) };
c_final   { zeroS = point(0m, 0m) };

cNuqtaLike { zeroM = point(0m, 0m); zeroS = point(0m, 0m) };

cDiacritic { zeroM = point(0m, 0m) };

endtable;


//
//  NUQTA POSITIONING
//

table(positioning)

pass(2)

// Use wider spaces for Latin text.
cSpace {advance.x += 200m}  /  _  cLatin;
cSpace {advance.x += 200m}  /  cLatin  _;


// Upper and lower nuqta attachment

table(glyph)

// For some reason I have to subtract something to make these things work. :-/
cn1LowerDia { nByLowerM = point(n1LowerM.x, n1LowerM.y - 1m) };
cn23LowerDia { nByLowerM = point(n23LowerM.x, n23LowerM.y - 1m) };

cTakes_nLowerDia = (cTakes_n1LowerDia cTakes_n23LowerDia);

// For attaching any kind of nuqta-like thing...
cHasUpperMaux = (cNuqtaUpper, gHamzaAbove, g__hamzaArabic, g__smallTah, g__smallTah2dots, g__smallV);
cNuqtaUpper { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };
gHamzaAbove { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__hamzaArabic  { nUpperMaux = point(hamzaUpperM.x, hamzaUpperM.y + 1m) };
g__smallTah { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallTah2dots { nUpperMaux = point(tahUpperM.x, tahUpperM.y + 1m) };
g__smallV  { nUpperMaux = point(nUpperM.x, nUpperM.y + 1m) };


// Intersection classes:

cTakes_hamzaAndN23LowerDia = cTakes_n23LowerDia;
cTakes_hamzaAndN23LowerDia &= cTakes_hamzaUpperDia;

cTakes_hamzaAndHehhookDia = cTakes_hamzaUpperDia;
cTakes_hamzaAndHehhookDia &= cTakes_hehhookDia;

cTakes_ringAndNUpperDia = cTakes_nUpperDia;
cTakes_ringAndNUpperDia &= cTakes_ringDia;

endtable;

// Special bariyeh rules: move any nuqtas within three chars of a bariyeh down.

// X+NxL  Y+NyL  Z+Nz  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	cMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyU  Z+NzL  Bariyeh
// Here we attach the upper nuqta too, since if we back up to attach it, it will reattach and mess up
// the second lower nuqta.
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	c_medial   cHasUpperMaux   { attach {to = @Y; at = nUpperS; with = nUpperMaux } }
	cMedBy cNuqtaLower       { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y _=Ny DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyL  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  c_medial=Y DIACS  _=Z _=Nz DIACS  ^  gBariyehFin=By;

// X+NxL  Y+NyL  Z  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByRightLowerS; with = nByLowerM } }
	cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidLeftLowerS; with = nByLowerM } }
	/ _=B1 _=L1 DIACS  _=B2  _=L2  DIACS  ^ cMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;

// X+NxL  Y+NyL  Bariyeh
cTakes_nLowerDia cNuqtaLower { underBy = true; attach {to = @By; at = nByMidRightLowerS; with = nByLowerM } }
	cMedBy cNuqtaLower { underBy = true; attach {to = @By; at = nByLeftLowerS; with = nByLowerM } }
	/ _=X _=Nx DIACS  _=Y  _=Ny DIACS  ^ gBariyehFin=By;

// X+Nx Y Bariyeh 
cTakes_nLowerDia  cNuqtaLower { underBy = true; attach {to = @By; at = nByCenterLowerS; with = nByLowerM } }
	/ _=B _=L  DIACS  ^ cMedBy cNuqtaLikeUpper? DIACS  gBariyehFin=By;



// Not really needed, because all glyphs with lower diacs can take upper diacs
//table(glyph)
//cTakes_n1Lower_and_nUpperDia = cTakes_n1LowerDia;
//cTakes_n1Lower_and_nUpperDia &= (cTakes_nUpperDia);
//endtable;

// kaf-top, nuqta(s) below
/*
cTakes_kafTopDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	ckafTopDia { attach {to = @K; at = kafTopS; with = kafTopM } }
	/ _=K  _=L  _=T;


cTakes_gafStrokeDia
	cn1LowerDia { attach {to = @K; at = n1LowerS; with = n1LowerM } }
	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
	/ _=K  _=L  _=S;
*/

// tah above, nuqta(s) below
cTakes_tahUpperDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=L  _=U;
// Do we need this? We shouldn't need to attach a tah to a glyph that doesn't take a tah.
//cTakes_n1LowerDia
//	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
//	ctahUpperDia { attach {to = @B; at = nUpperS; with = tahUpperM } }
//	/ _=B  _=L  _=U;

// nuqtas above, hehhook below
cTakes_hehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// nuqtas above and below
cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  _=L  _=U;

// hamza above, nuqtas below
cTakes_hamzaAndN23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
(cBehIni cBehMed)
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=L  _=H;


// Upper nuqta-like attachment


////gJeemFin  cNuqtaLike { attach {to = @J; at = point(574m, 1274m); with = nUpperM} }
////	/  gJeemMedJm=J  cNuqtaLike?  _=J  _=N;

//cTakes_n1hUpperBehSpecialDia
//	cNuqtaLikeUpper { attach {to = @B; at = n1hUpperBehSpecialS; with = nUpperM } }
//	/ _=B  _=U;

// Put hamza rules first to make sure to use hamza APs for them.
cTakes_hamzaAndHehhookDia
	chehhookDia { attach {to = @B; at = hehhookS; with = hehhookM } }
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=H  _=U;

cTakes_hamzaUpperDia
	chamzaUpperDia { attach {to = @B; at = hamzaUpperS; with = hamzaUpperM } }
	/ _=B  _=U;

cTakes_hamzaLowerDia
	chamzaLowerDia { attach {to = @B; at = hamzaLowerS; with = hamzaLowerM } }
	/ _=B  _=U;

// for beh forms (ie, yeh-hamza), attach hamza at nUpper.
// TODO: add real hamzaUpper APs to beh forms.
(cBehIni cBehMed)
	chamzaUpperDia { attach {to = @B; at = nUpperS; with = hamzaUpperM } }
	/ _=B  _=H;

// Bar after kaf needs to be offset vertically.
/*
(cLamMed cLamFin)
	cbarDia { attach {to = @L; at {x = barS.x; y = barS.y + 380m}; with = barM } }
	/ (cKafIni cKafMed)  MARKS  _=L  _=B;
*/

cTakes_barDia
	cbarDia { attach {to = @B; at = barS; with = barM } }
	/ _=B  _=U;

cTakes_squiggleDia
	csquiggleDia { attach {to = @K; at = squiggleS; with = squiggleM } }
	/ _=K  _=S;

////cTakes_gafStrokeDia
////	cgafStrokeDia { attach {to = @K; at = gafStrokeS; with = gafStrokeM } }
////	/ _=K  _=S;

// Use smallV AP if present, otherwise small-V will attach at nUpper - no longer used.
////cTakes_smallVDia
////	g__smallV { attach {to = @B; at = smallVS; with = nUpperM } }
////	/ _=B  _=U;

cTakes_nUpperDia
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U;

cTakes_tahUpperDia
	ctahUpperDia { attach {to = @B; at = tahUpperS; with = tahUpperM } }
	/ _=B  _=U;

// nuqtas above, ring below
cTakes_ringAndNUpperDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	cnUpperDia { attach {to = @B; at = nUpperS; with = nUpperM } }
	/ _=B  g__kafTop_null?  _=U _=R;

cTakes_ringDia
	cringDia { attach {to = @B; at = ringS; with = ringM } }
	/ _=B  g__kafTop_null?  _=R;

// Odd situation, but just in case:
c_isolate
	gMaddaAbove { attach {to = @B; at = mUpperS; with = mUpperM } }
	/ _=B  _=M;


// Lower nuqta attachment

cTakes_n1LowerDia
	cn1LowerDia { attach {to = @B; at = n1LowerS; with = n1LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_n23LowerDia
	cn23LowerDia { attach {to = @B; at = n23LowerS; with = n23LowerM } }
	/ _=B  g__kafTop_null?  _=L;

cTakes_tahLowerDia
	ctahLowerDia { attach {to = @B; at = tahLowerS; with = tahLowerM } }
	/ _=B  _=U;

// Hehhook
cTakes_hehhookDia  g__hehHook_small  { attach {to = @B; at = hehhookS; with = hehhookM } }
	/ _=B  _=H;

// Hehhook - big
////////attachR_BN(	gHehGoalIni,	g__hehHook_big,		default2,		default2_)


// TEMPORARY - fall-back attachment
// Needed to test in Graphite1.
(c_initial c_medial c_final)  g__kafTop_null;

(c_initial c_medial c_final)  cNuqtaLike { attach {to = @1; at = zeroS; with = zeroM } };


// Subtending marks

// NB: at this point digits should be in visual order, right to left,
// so we attach the left-most (logically first) to the sign, and proceed to the right.

cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign4=S;

cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign3=S;

cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign2=S;

cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSign1=S;

// However, there is a bug in some implementations (eg Firefox) where the numbers are still in
// logical order.

cSign4=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true}
	cSignDigit=D4 { attach {to=@D3; at=digitS; with=digitM }; insert = true};
	
cSign3=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitS; with=digitM }; insert = true};
	
cSign2=S
	cSignDigit=D1 { attach {to=@S;  at=digitS; with=digitM }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitS; with=digitM }; insert = true};
	
cSign1=S
	cSignDigit { attach {to=@S;  at=digitS; with=digitM }; insert = true};

endpass;  // 2

endtable;  // pos


#if DO_COL_FIX

// Define fake right and left bounding boundaries that will be compared to the side-bearing marks
// and used to determine the ideal margin/kerning.

table(glyph) {AttributeOverride = 0}

// Define for all needed glyphs where they have not been defined in the font.
c_initial {kernBbRightS = point(0m,0m) };
c_final {kernBbLeftS = point(0m,0m) };
c_isolate {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };

gComma {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };
gFullStop {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };
gSemicolon {kernBbRightS = point(0m,0m); kernBbLeftS = point(0m,0m) };
cKernPunct = (gComma gFullStop gSemicolon);

endtable;


table(glyph)

cPostKernable = (c_initial  c_isolate  cKernPunct) {
	dbgBbRight = bb.right; dbgRsb = rsb; dbgAdv = advancewidth;
	kernRsb = advancewidth - ((kernBbRightS.x == 0) ? bb.right : kernBbRightS.x);
};

cKernable = (c_isolate  c_final  cKernPunct)
{
	dbgBbLeft = bb.left; dbgLsb = lsb;
	kernLsb = ((kernBbLeftS.x == 0) ? bb.left : kernBbLeftS.x);
}


c_jumpTail = ( cJeemFin, gAinFin );

gKafMed {collexclude.glyph = g__kaf_exclude};
gKafMedBe {collexclude.glyph = g__kaf_exclude};
gKafMedBeF {collexclude.glyph = g__kaf_exclude};
gKafMedBeM2 {collexclude.glyph = g__kaf_exclude};
gKafMedJm {collexclude.glyph = g__kaf_exclude};
gKafMedRe {collexclude.glyph = g__kaf_exclude};
gKafMedSn {collexclude.glyph = g__kaf_exclude};
gKafMedSd {collexclude.glyph = g__kaf_exclude};
gKafMedTaF {collexclude.glyph = g__kaf_exclude};
gKafMedAi {collexclude.glyph = g__kaf_exclude};
gKafMedFe {collexclude.glyph = g__kaf_exclude};
gKafMedQf {collexclude.glyph = g__kaf_exclude};
gKafMedMm {collexclude.glyph = g__kaf_exclude};
gKafMedNn {collexclude.glyph = g__kaf_exclude};
gKafMedHgM {collexclude.glyph = g__kaf_exclude};
gKafMedHgF {collexclude.glyph = g__kaf_exclude};
gKafMedHd {collexclude.glyph = g__kaf_exclude};
gKafMedCh {collexclude.glyph = g__kaf_exclude};
gKafMedBy {collexclude.glyph = g__kaf_exclude};
gKafMedDk {collexclude.glyph = g__kaf_exclude};
gKafMedBeRe {collexclude.glyph = g__kaf_exclude};
gKafMedBeNn {collexclude.glyph = g__kaf_exclude};
gKafMedBeHg {collexclude.glyph = g__kaf_exclude};
gGafMed {collexclude.glyph = g__kaf_exclude};
gGafMedBe {collexclude.glyph = g__kaf_exclude};
gGafMedBeF {collexclude.glyph = g__kaf_exclude};
gGafMedBeM2 {collexclude.glyph = g__kaf_exclude};
gGafMedJm {collexclude.glyph = g__kaf_exclude};
gGafMedRe {collexclude.glyph = g__kaf_exclude};
gGafMedSn {collexclude.glyph = g__kaf_exclude};
gGafMedSd {collexclude.glyph = g__kaf_exclude};
gGafMedTaF {collexclude.glyph = g__kaf_exclude};
gGafMedAi {collexclude.glyph = g__kaf_exclude};
gGafMedFe {collexclude.glyph = g__kaf_exclude};
gGafMedQf {collexclude.glyph = g__kaf_exclude};
gGafMedMm {collexclude.glyph = g__kaf_exclude};
gGafMedNn {collexclude.glyph = g__kaf_exclude};
gGafMedHgM {collexclude.glyph = g__kaf_exclude};
gGafMedHgF {collexclude.glyph = g__kaf_exclude};
gGafMedHd {collexclude.glyph = g__kaf_exclude};
gGafMedCh {collexclude.glyph = g__kaf_exclude};
gGafMedBy {collexclude.glyph = g__kaf_exclude};
gGafMedDk {collexclude.glyph = g__kaf_exclude};
gGafMedBeRe {collexclude.glyph = g__kaf_exclude};
gGafMedBeNn {collexclude.glyph = g__kaf_exclude};
gGafMedBeHg {collexclude.glyph = g__kaf_exclude};
gKafMedBe_base {collexclude.glyph = g__kaf_exclude};
gKafMedBeM1_base {collexclude.glyph = g__kaf_exclude};
gKafMedBeM2_base {collexclude.glyph = g__kaf_exclude};
gKafMedBeRe_base {collexclude.glyph = g__kaf_exclude};
gKafMedBeNn_base {collexclude.glyph = g__kaf_exclude};
gKafMedBeHg_base {collexclude.glyph = g__kaf_exclude};
gKafMedBeF_base {collexclude.glyph = g__kaf_exclude};
gKafMedJm_base {collexclude.glyph = g__kaf_exclude};
gKafMedRe_base {collexclude.glyph = g__kaf_exclude};
gKafMedSn_base {collexclude.glyph = g__kaf_exclude};
gKafMedSd_base {collexclude.glyph = g__kaf_exclude};
gKafMedTaM_base {collexclude.glyph = g__kaf_exclude};
gKafMedTaF_base {collexclude.glyph = g__kaf_exclude};
gKafMedAi_base {collexclude.glyph = g__kaf_exclude};
gKafMedFe_base {collexclude.glyph = g__kaf_exclude};
gKafMedQf_base {collexclude.glyph = g__kaf_exclude};
gKafMedMm_base {collexclude.glyph = g__kaf_exclude};
gKafMedNn_base {collexclude.glyph = g__kaf_exclude};
gKafMedDk_base {collexclude.glyph = g__kaf_exclude};
gKafMedHgM_base {collexclude.glyph = g__kaf_exclude};
gKafMedHgF_base {collexclude.glyph = g__kaf_exclude};
gKafMedHd_base {collexclude.glyph = g__kaf_exclude};
gKafMedCh_base {collexclude.glyph = g__kaf_exclude};
gKafMedBy_base {collexclude.glyph = g__kaf_exclude};


// Note gGafMed_short doesn't need an exclude glyph because it is tucked under the following kaf/gaf so there
// isn't room for anything to jump above it anyway. - OBSOLETE

cls_excludingGlyphs = (cKafMed cKafMed_base)
	{collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

gKafFin {collexclude.glyph = g__kaf_exclude};
gGafFin {collexclude.glyph = g__kaf_exclude};

cls_excludingGlyphs_kern = (gKafFin, gGafFin)
	{collexclude {offsetx = kafExcludeS.x; offsety = kafExcludeS.y}};

endtable;


// Nuqta collision fixing

table(positioning)

if (collFix > 0)

pass(3)

// Set up for collision fixing

#define MAXKERN 5000m
#define MINKERN -700m
#define MINKERN_TIGHT -3000m
#define MINKERN_WIDE -200m
#define STDMARGIN 150m
#define STDMARGINWT 400
#define STDMARGIN_N1 150m
#define STDMARGINWT_N1 200
#define STDMARGIN_N2 150m
#define STDMARGINWT_N2 200
#define STDMARGIN_DIAC 200m
#define STDMARGINWT_DIAC 400

#define KERNMARGIN_TIGHT 150m
#define KERNMARGIN_MED 300m
#define KERNMARGIN_WIDE 400m


#define ORDER_UNUQTAS 1
#define ORDER_LNUQTAS 2
#define ORDER_LNUQTAS_SUB_BYEH 3

#define ORDER_UDIACS 4
#define ORDER_LDIACS 5

table(glyph) {AttributeOverride = 1}

cNuqtaLikeUpper {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_UNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 50 };
		valign { height = 200m;	weight = 500 }
	}
};

gHighHamza { sequence.class = 0 };

cNuqtaLikeLower {
	collision { margin = STDMARGIN; marginweight = STDMARGINWT };
	sequence {
		class = ORDER_LNUQTAS;	order = ORDER_LEFTDOWN;
		above { xoffset = 100m;	weight = 400 };
		below { xlimit = -50m;	weight = 500 }; // weight was 50
		valign { height = 200m;	weight = 500 }
	}
};

g__bar { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };
g__attachedRing { collision { margin = STDMARGIN; marginweight = STDMARGINWT } };

cgafStrokeDia { collision { margin = 0; flags = 0 }; sequence { class = 0; order = 0 } };


// Smaller nuqta glyphs need larger margins:
g__dot1u { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };		// was 150
g__dot1l { collision {margin = STDMARGIN_N1; marginweight = STDMARGINWT_N1} };		// was 150
g__dot2u { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };		// was 125
g__dot2l { collision {margin = STDMARGIN_N2; marginweight = STDMARGINWT_N2} };		// was 125


cDiacriticUpper {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; } - set in the rule
};

gNoonGhunnaMark { collision.margin = 300m; marginweight = 300 }; // override

cBase = (c_isolate, c_initial, c_medial, c_final, g_zerojoin);

cDiacriticLower {
	collision { margin = STDMARGIN_DIAC; marginweight = STDMARGINWT_DIAC }
	//// ; sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; } - set in the rule
};

//cNuqtaLikeAbove { collision.order { class = ORDER_UNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };
//cNuqtaLikeBelow { collision.order { class = ORDER_LNUQTAS; enforce = ORDER_LEFT + ORDER_DOWN; } };

endtable; // glyph


// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags); collision.flags = SET_IGNORE(collision.flags) };


g__kafTop_null { collision {flags = COLL_FREEZE} }  /  cBase  _ ;   // make context long enough to give precedence


// Upper nuqtas

// Gaf strokes are considered part of the base - they don't move.
cgafStrokeDia { collision.flags = COLL_FREEZE }  /  cBase  _ ;     // make context long enough to give precedence

// Things on top of alefs should never move horizontally. For now, just don't let them move at all.
// Also, don't force preceding nuqta-like things to move above them.
cNuqtaLikeUpper { collision.flags = COLL_FREEZE; sequence.class = 0 }  /  (gAlef cAlefFin)  _;


// Small V over lam needs to stay nicely centered.
g__smallV { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 50m;
	min.y = -300m;
	max.y = 1000m;
} }  /  (cLamIni cLamMed)  _;

	
// Special case: if there is a nuqta before a zah, scootch the nuqta of the
// zah down pretty close to the base.
/**
cNuqtaLikeUpper { 
	shift { x = 50m; y = -150m }; // note that shifting in RTL moves forward, ie, left.
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 100m;
		min.y = -100m;
		max.y = 300m;
	}
} /  cNuqtaLikeUpper=N1 DIACS  cTahMed  _=N2 ;
**/


// The nuqta on the zah (tah form) fits nicely above it, so it is not normally helpful to move it.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;   // don't let this one move left much
	max.x = 100m;
	min.y = -200m;  // shouldn't need to move vertically either, at least by much
	max.y = 300m;
} } / cTahMed _ ;


//
// Exception to special case below when there is a previous lam/kaf.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } / (cLamIM cKafIM) cDiacritic?  cBase  _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);

// Special cases involving kaf tops - allow nuqtas to move further right than normal.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 800m; // a lot more than normal
	min.y = -300m;
	max.y = 1000m;
} } / _ cDiacritic? [cJeemMed cNuqta? cDiacritic?]? (cKafMed cKafFin);

// Need more flexibility in getting away from kinked kafs
// TODO: use a class including all kinked kafs.
g__dot3u { collision {
	flags = SET_FIX(collision.flags);
	min.x = -500m;
	max.x = 250m;
	min.y = -300m;
	max.y = 1000m;
} } / (gGafMedBe_alt gGafMedSn_alt gKafIniBeM2_alt)  cBase _ ;


// Special case: jeem + teh/theh - allow more movement to get the nuqta on the jeem to the right of the nuqta on the beh form.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m;
	min.y = -300m;
	max.y = 1000m;
} } / cJeemMed _ cDiacritic? cBehMed cNuqtaLikeUpper;


// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 350m; // more than normal
	min.y = -300m;
	max.y = 1000m;
} } / c_initial _;

// Nuqtas on finals can be moved quite a bit to the left.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -500m;   // more than normal
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} } / c_final _;

/*** Special case: jeem followed by nuqta
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	margin = 250m;
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} }  /  cJeemIni  cNuqtaLike?  cBase  _; 
***/

// Default case: nuqtas above (other than initial) can move more to the left than the right.
cNuqtaLikeUpper { collision {
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 200m;
	min.y = -300m;
	max.y = 1000m;
} };


// Middle nuqta-like stuff: bars and rings
// Ideally it would be nice to be able to move the bars up and down a little to avoid
// collisions, but to do that we would need to be able to ignore the base (lam) from
// the perspective of the bar.

g__bar { collision.flags = COLL_FREEZE }    /  cBase  _ ;  // add context to increase precedence
g__attachedRing { collision.flags = COLL_FREEZE }  /  cBase  _ ;

// Lower nuqtas

// Nuqtas before certain finals can move down quite a bit to jump below swashes.
// Note that if we make the lower limit too low, the nuqtas will jump completely *below* 
// the swash, which is not what we want. We want to be down and to the right.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -200m;
		max.x = 700m;	// a lot!
		min.y = -1600m; // a lot!
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / _  c_jumpTail;

// Gueh vertical dots must stay close to the kaf stem.
g__dot2vl {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -50m;
		max.x = 150m;
		min.y = -1000m;
		max.y = 300m;
  };
  sequence { class = 0; order = 0 } // don't enforce the order relative to the other glyphs
} / cKafIM  g__kafTop_null  _=N;


// Nuqtas below a bariyeh cannot move up, shouldn't need to move down, and they don't flow diagonally.
cNuqtaLikeLower {
	collision {
		flags = SET_FIX(collision.flags);
		min.x = -400m;
		max.x = 400m;
		min.y = -20m;
		max.y = 0m;
  };
  sequence { class = 0; order = 0 }
} / c_initial?  _ {underBy == true};


// Heh-hooks need to be kept centered under the base.
g__hehHook_small { collision {
	flags = SET_FIX(collision.flags);
	min.x = -50m;
	max.x = 50m;
	min.y = -1000m;
	max.y = 50m;
} };

// Nuqtas on initials can be moved quite a bit to the right.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 400m;  // 600 breaks \u067E\u0650\u06CC\u064F\u0648
	min.y = -1000m;
	max.y = 300m;
} }  /  c_initial  _;

// Default case: nuqtas below (other than initial) can move more to the right than the left.
cNuqtaLikeLower { collision {
	flags = SET_FIX(collision.flags);
	min.x = -200m;
	max.x = 350m;   // making this 400 helps \u067E\u0650\u06CC\u0686\u06BE\u06D2 but breaks other things
	min.y = -1000m;
	max.y = 300m;
} };

// Exclusion glyphs for space above kafs and gafs

// For ngoeh, don't using the exclusion glyph - the nuqtas need to go right on top of the gaf.
(cls_excludingGlyphs cls_excludingGlyphs_kern) { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
} } / _  g__kafTop_null? g__dot2u;

cls_excludingGlyphs { collision {
	flags = CLEAR_FIX(collision.flags);
	flags = CLEAR_KERN(collision.flags);
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} };

cls_excludingGlyphs_kern { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	max.x = MAXKERN; min.x = MINKERN;
	margin = 100m;
    // min/max.y are omitted for kernable glyphs
	exclude.glyph = collexclude.glyph;
	exclude.offset.x = collexclude.offsetx;
	exclude.offset.y = collexclude.offsety;
} };


// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.
// We actually set the kerning parameters in the final pass. But here, at least indicate
// which glyphs can be kerned, which affects how shifting works around them.

cKernable { collision {
	//---flags = SET_FIX(collision.flags); -- move actual kerning to end of process
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	////max.x = 300m; min.x = 0;  // kerning right is logically equivalent to shifting left in RTL
	//---max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };


// Other bases are not moved.
(c_initial c_medial) { collision { flags = COLL_FREEZE } };

cDiacritic { collision.flags = SET_IGNORE(collision.flags) };	// these have not been attached, so don't bother with them

endpass; // 3

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.
if (collFix > 1)
pass(4) { CollisionFix = 5 }
// Perform base + nuqta collision fixing. Any failures leave for now.
endpass;
endif;

/**************************************

#define CHARSEQ cMed cNuqtaLike? cDiacritic?
#define SEQ2 [[CHARSEQ]? CHARSEQ]?
#define SEQ3 [[[CHARSEQ]? CHARSEQ]? CHARSEQ]?
#define YBELOWBYEH -450

if (collFix > 1)
pass(4) { CollisionFix = 4 }

// Next: adjust for nuqtas moved below a bariyeh.
// Needed for, eg, \u0686\u067E\u0679\u06CC\u0646\u06D2

cNuqtaLikeLower {
	collision.max.y = 0m; // ideally this would be set to what it is shifted by already
	sequence { class = ORDER_LNUQTAS_SUB_BYEH; order = 0 }
}  / (c_medial c_initial)  _ {position.y < 0}  cDiacritic?  SEQ2 gBariyehFin;

// Nuqtas still above a bariyeh need more flexibility; if they are initial, let them move right:
cNuqtaLikeLower {
	collision.max.x = 750m;
	sequence.class = 0;
}  / cIni  _ {position.y > 100m}  cDiacritic?  SEQ2 gBariyehFin;


endpass;  // 4
endif;    // collFix > 1

*****************************************/

endtable;

#endif // DO_COL_FIX

/*****  Not needed - the collision-fix pass sets all the positions accurately.
table(glyph)
cNonBaseTemp = (cNuqtaLike  g__kafTop_null)
endtable;

#define NOTSET 12345  // some number that is not likely to be a real value

c_initial {user2 = position.y}  c_final {user2 = position.y}   / _=I  MARKS2N  _=F;
c_initial {user2 = position.y}  c_medial {user2 = position.y}  c_final {user2 = position.y} / _=I MARKS2N  _=M MARKS2N _=F;

c_medial {user2 = NOTSET}  c_medial {user2 = position.y}   c_final {user2 = NOTSET}
	/ ^ cIniMed cNonBaseTemp?  _=M1  cNonBaseTemp?  _=M2 cNonBaseTemp?  _=F {user2==0};

c_medial {user2 = NOTSET}  c_medial {user2 = position.y}
	/ ^ cIniMed MARKS2N  _=M1 MARKS2N  _=M2 {user2 == NOTSET};

c_initial {user2 = position.y}  c_medial {user2 = position.y}  /  _=I  MARKS2N  _=M {user2==NOTSET} ;

// Do this last:
c_final {user2 = position.y}  /  _ {user2 == NOTSET};
*****/


table(positioning)

//
//	KAF HEIGHT ADJUSTMENTS
//

table(glyph)

cNuqtaLikeUpperNoKT = (cNuqtaLikeUpper);
cNuqtaLikeUpperNoKT -= (g__kafTop_null);

c_narrow = (gBehMed gMeemMed gAinMed);

endtable;

pass(5)

// Collision fixing

// Tall: large-nuqta + kaf 
cNuqtaUpperLarge  cKafMed_medium  g__kafTop_null  
	>  @N /*coll-fix*/  cKafMed_base$K  cKafMed_top_tall$K
	/  _=N  cDiacritic?  _=K  _=T;

// Tall: lam/tah + kaf
cKafMed_medium  g__kafTop_null  
	>  cKafMed_base$K  cKafMed_top_tall$K
	/  cBaseTall  MARKS  _=K  _=T;

cNuqtaLikeUpperNoKT  cKafMed_medium  g__kafTop_null  
	>  @N /*coll-fix*/ cKafMed_base$K  cKafMed_top_tall$K
	/  _=N cBaseTall  MARKS  _=K  _=T;

// Tall: nuqta + diac + kaf
cNuqtaLike  cKafMed_medium  g__kafTop_null  
	>  @N /*coll-fix*/  cKafMed_base$K  cKafMed_top_tall$K
	/  _=N  cDiacriticUpper  _=K  _=T;

// Tall: nuqta + nuqta + kaf (eg, sheen + teh + kaf)
cNuqtaLikeUpperNoKT  cNuqtaLikeUpper  cKafMed_medium  g__kafTop_null  
	>  @N1  @N2  cKafMed_base$K  cKafMed_top_tall$K
	/  _=N1  cDiacritic?  c_medial  _=N2  cDiacritic?  _=K  _=T;

// nuqta + diac + kaf => default
cKafMed_medium  g__kafTop_null  >  @K  @T
	/  cNuqtaUpperSmall  cDiacritic  _=K  _=T;

// Short + medium-short: gaf + ??? + kaf/gaf
cGafIM_medium g__kafTop_null  cKafMed_medium g__kafTop_null
	>  cGafIM_base$G  cGafIM_top_shorter$G  cKafMed_base$K  cKafMed_top_medshort$K
	/  _=G _=Tg  cNuqtaLike? cDiacritic?  (gMeemMed gFehMed gBehMed gHehGoalMed gHehDoMed) cNuqtaLike? cDiacritic? _=K _=Tk;

// Gaf + kaf/gaf-medial => shorter
cGafIM_medium g__kafTop_null  cKafMed_medium g__kafTop_null
	>  cGafIM_base$G  cGafIM_top_shorter$G  @K  @Tk
	/  _=G _=Tg  cNuqtaLike? cDiacritic? _=K _=Tk;

// Gaf + kaf/gaf-final => short
cGafIM_medium g__kafTop_null  (gKafFin gGafFin)
	>  cGafIM_base$G  cGafIM_top_short$G  @K
	/  _=G _=Tg  cNuqtaLike? cDiacritic? _=K;

// Medium-short: lam/tah + jeem + kaf
cBaseTall  cKafMed_medium  g__kafTop_null  
	>  @B  cKafMed_base$K  cKafMed_top_medshort$K
	/  _=B  cNuqtaLike? cDiacritic?  cJeemMed  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Medium-short: tah + beh/meem/ain + kaf...
cTahIM  cKafMed_medium  g__kafTop_null  
	>  @Ta  cKafMed_base$K  cKafMed_top_medshort$K
	/  _=Ta cNuqtaLike? cDiacritic?  c_narrow cNuqtaLike? cDiacritic?  _=K  _=T;

// Medium-short: nuqta + jeem + kaf...
cNuqtaLikeUpperNoKT  cKafMed_medium  g__kafTop_null  
	>  @N /*coll-fix*/  cKafMed_base$K  cKafMed_top_medshort$K
	/  _=N  cDiacritic?  cJeemMed  cNuqtaLike?  cDiacritic?  _=K  _=T;

// Short round form: tah + kaf + lam/alef
cTahIM  cKafRound_medium  g__kafTop_null
	>  @Ta  cKafRound_short  @Null
	/  _=Ta MARKS  _=K MARKS  _=Null;



// Situations where short kaf is needed (except above)

cNuqtaLikeUpper?  cDiacritic?  cKafIM_medium  g__kafTop_null
	>	@N  @D  cKafIM_base$K  cKafIM_top_shorter$K
	/  _=N  _=D  _=K {position.y > 1350m}  _=T;

cNuqtaLikeUpper?  cDiacritic?  cKafIM_medium  g__kafTop_null
	>	@N  @D  cKafIM_base$K  cKafIM_top_short$K
	/  _=N  _=D  _=K {position.y > 1200m}  _=T;



// If a nuqta is not near a height-adjusted kaf, turn off collision fixing for next time around.
// Note that this also turns it off for g__kafTop_null, which is fine (although it should already be off).
cNuqtaLike { collision.flags = CLEAR_FIX(collision.flags) };

endpass;  // pass 5


pass(6)

// Due to an infelicity in the Graphite engine, we can't subsitute and attach in the same rule,
// so we have to do it later.

// ngoeh nuqtas
cKafIM_base=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}}
	cNuqtaUpper { shift.x = @T.nDelta;  collision.flags = SET_FIX(collision.flags) };
cKafIM_base=B  cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM}}
	cNuqtaUpper { shift.x = @T.nDelta;  collision.flags = SET_FIX(collision.flags) };

// rings
cKafIM_base=B  ckafTop_bjDia=T {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}}
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM } };
cKafIM_base=B  cKaf_top=T      {att {to=@B; at=kafTopS;    with=kafTopM}}
	g__attachedRingMid { attach { to=@T; at=ringS; with=ringM } };

cKafIM_base=B  ckafTop_bjDia {att {to=@B; at=kafTop_bjS; with=kafTop_bjM}};
cKafIM_base=B  cKaf_top      {att {to=@B; at=kafTopS;    with=kafTopM}};

endpass;


//
//	DIACRITIC ATTACHMENT
//


// Order of glyphs: base, nuqta below, nuqta above, diacritics below, diacritics above
// But if an upper diacritic is in a "closer" mark class (eg, cMark1), it can come before the lower diacritic.

#if DO_COL_FIX
pass(7)
#else
pass(3)
#endif // DO_COL_FIX


// Attach diacritics
 
table(glyph) { AttributeOverride = false }
// Classes of nuqtas and things that attach closely like nuqtas.
// These are basically defined for the purpose of ignoring in the context of attaching
// diacritics to things.
c_attLikeNqUpper = (cNuqtaLikeUpper); // includes small tah
c_attLikeNqLower = (cNuqtaLikeLower, g__hehHook_small);
c_attLikeNqLowMid = (c_attLikeNqLower, cNuqtaLikeMiddle,
	g__kafTop_null); // diacs don't attach to this, so attach to the base even if this is there
c_attLikeNqUpMid = (c_attLikeNqUpper, cNuqtaLikeMiddle);
endtable;


/****
// Alternate approach to honorifics with diacritics - attach them to the diacritic:
table(glyph)
gZabar { honorificS = point(-200m, 300m) };
gPesh { honorificS = point(-200m, 300m) };
endtable;

cDiacriticUpper=D  chonorificDia=H {att {to=@D; at=honorificS; with=honorificM}; insert=true}
		/ ^ _  _ {att.to==0};
****/


// diacritic AND honorific attached to final base or its nuqta;
// honorific is positioned off to the left
cIsoFin=B  cNuqtaLikeUpper=N
	cDiacriticUpper=D {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^  _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

cIsoFin=B  
	cDiacriticUpper=D {att {to=@B; at=mUpperS; with=mUpperM}; insert=true}
	chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0}  _=H {att.to==0};

// honorific attached to final beh with lower nuqtas, w/o upper diac - 
// uses standard upper nuqta location raised a little higher
cBehFin=B  chonorificDia=H {att {to=@B; at {x=nUpperS.x; y=nUpperS.y + 300m}; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};

// honorific attached to final base w/o upper diac
cTakes_honorificDia=B  chonorificDia=H {att {to=@B; at=honorificS; with=honorificM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  c_attLikeNqUpper?  cDiacriticLower?  _=H {att.to==0};


// Nuqta + upper and lower diacritic
// Eg, noon-nuqta + noon-ghunna-mark + zair (\u0646\u0658\u0650)
cTakes_nUpperDia=B  cNuqtaUpper=N
	cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}}
	cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}}; 


// attach to nuqta
cTakes_mUpperDia  c_attLikeNqUpper=N  cDiacriticUpper {att {to=@N; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  _=N  cDiacriticLower? _=D {att.to==0};
cTakes_mLowerDia  c_attLikeNqLower=N  cDiacriticLower {att {to=@N; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _=B  _=N  c_attLikeNqUpMid?  _=D {att.to==0};


// Special contextual cases - eg, kaf/lam followed by tailed final 
cTakes_mLowerCDia=B  cDiacriticLower {att {to=@B; at=mLowerCS; with=mLowerM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0}  (gAinFin gChotiyehFin gChotiyehFin_bfkl gJeemFin);

// Only a few glyphs attach the small alef at a special place.
cTakes_alefDia=B  gKharizabar {att {to=@B; at=alefS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Attaching to final form, or nuqta, uses mUpper/LowerS.
cTakes_mUpperDia=B  cDiacriticUpper {att {to=@B; at=mUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_mLowerDia=B  cDiacriticLower {att {to=@B; at=mLowerS; with=mLowerM}; insert=true}
		/ ^ _=B  c_attLikeNqUpMid?  _=D {att.to==0};

// Attaching to initial/medial base - uses stationary nuqta APs.
cTakes_nUpperDia=B  cDiacriticUpper {att {to=@B; at=nUpperS; with=mUpperM}; insert=true}
		/ ^ _=B  cKafTop?  c_attLikeNqLowMid?  cDiacriticLower?  _=D {att.to==0};
cTakes_n1LowerDia=B  cDiacriticLower {att {to=@B; at=n1LowerS; with=mLowerM}; insert=true}
		/ ^ _=B  cKafTop?  c_attLikeNqUpMid?  _=D {att.to==0};

// attach to diacritic
cDiacriticUpper=D1  cDiacriticUpper {att {to=@D1; at=mUpperS; with=mUpperM}; insert=true}
	/ _=D1 ^ _=D2 {att.to==0};
cDiacriticLower=D1  cDiacriticLower {att {to=@D1; at=mLowerS; with=mLowerM}; insert=true}
	/ _=D1 ^ _=D2 {att.to==0};

// Remove if we create a nuqta+smalltah glyph:
////c_attLikeNqUpper=N  g__smallTah=T {att {to=@N; at=mUpperS; with=mUpperM} };


endpass; // pos - 7 (or 3)


// Kerning pair adjustments

#define pairKern user3
// currently not used
#define marginSet user4


table(glyph) { AttributeOverride = 1 }

// alef, dal, reh, reh-sshg, reh-jkl, reh-???, waw, heh-goal, noon

cKernable { kernPreAlef = 0m; kernPreDal = 0m; kernPreReh = 0m; kernPreWaw = 0m;
	kernPreLamAlef = 0m; kernPreKafNoSp = 0m; kernPreShort = 0m;  // kernPreInitial = 0m };
	minKernDelta = 0m };

gDal		{ kernPreAlef = -60m };
gDalFin		{ kernPreAlef = -50m };
gReh		{ kernPreAlef = -120m; kernPreDal = -30m; kernPreReh = -30m; kernPreWaw = -30m; kernPreLamAlef = -30m;
				// Before a two-letter sequence:
				kernPreShort = 80m };
gRehFin_jkl	{ kernPreAlef = -70m };
gWaw		{ kernPreAlef = -80m };

gRehFin { minKernDelta = -400m };
gRehFin_jkl { minKernDelta = -400m };
gRehFin_sshg { minKernDelta = -400m };
gRehFin_hgM { minKernDelta = -400m };

// Don't let punctuation kern underneath following segment:
cKernPunct { minKernDelta = MINKERN * -1 };

// To account for the fact that the top edge of the kaf pushes the top of the alef away:
gAlef { kernPreKafNoSp = -150m };
gAlefFin { kernPreKafNoSp = -80m };

endtable; // glyph


pass(8)

// Special cases involving nuqtas.

table(glyph)
gNlWide = (g__dot2l  g__dot3l  g__dot4l);
endtable;

// \u0631\u06CC\u0631
(gDal gReh)  gBehIniRe  gNlWide {shift {x = 170m; y = -300m}}  gRehFin_jkl;

// \u0627\u06CC\u0645\u0627
gAlef  gBehIniMmX  gNlWide {shift {x = 300m; y = -650m}}  gMeemMed_alt  gAlefFin;


// Low priority special case:
////gRehFin {collision.margin = 50m; marginSet = 1}  gBehIniFe  gNlWide; /// {shift {x = 150m; y = 70m}; collision.margin = 50m};


// Set up kerning pairs.

cKernable { pairKern = kernPreAlef }  /  _  MARKS  cNoJoin?  (cAlefIso);
cKernable { pairKern = kernPreDal  }  /  _  MARKS  cNoJoin?  (cDalIso);
cKernable { pairKern = kernPreReh  }  /  _  MARKS  cNoJoin?  (cRehIso);
cKernable { pairKern = kernPreWaw  }  /  _  MARKS  cNoJoin?  (cWawIso);
cKernable { pairKern = kernPreLamAlef} / _  MARKS  cNoJoin?  (gLamAlef gLamIniAl);

cKernable { pairKern = kernPreKafNoSp }   /  _  MARKS  (gKaf  gGaf  cKafIni);

// Before a two-letter sequence:
cKernable { pairKern = kernPreShort } / _  MARKS  cNoJoin?  c_initial MARKS  c_final;


// Bogus rule that will never fire (for if we disable this pass):
///////////////gRrehFin_jkl cDiacritic cDiacritic cDiacritic { user4 = 10 };

endpass;  // 8


#if DO_COL_FIX

// Diacritic collision fixing and kerning

if (collFix > 0)

pass(9) // { CollisionFix = 4; AutoKern = true }


// Set up diacritic collision fixes and kerning.

// Spaces serve as boundaries between collision ranges.
cSpace { collision.flags = SET_START_END(collision.flags) };  /// collision.flags = SET_IGNORE(collision.flags) };

// Kaf exclusion glyphs don't affect diacritics.
(cls_excludingGlyphs cls_excludingGlyphs_kern) { collision.exclude.glyph = 0 };


cKafTop { collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = CLEAR_FIX(collision.flags);
	};
	sequence.class = 0
};


if (collFix >= 2)

// For special cases:
cKernable {collision {
	flags = SET_FIX(collision.flags);
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;}}
	/  _ {marginSet == 1}  cNuqtaLike?  DIACS  cPostKernable;


gNameMarker  { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -400m;
	max.x = 400m;
	min.y = -300m;
	max.y = 800m;
} };

chonorificDia { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	margin = 300m; marginweight = 500; // don't squeeze these in!
	min.x = -250m;
	max.x = 0m;
	min.y = -50m;
	max.y = 500m;
} };

// Diacritics attached to bases:
cDiacriticUpper {
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -250m;
		max.x = 250m;
		min.y = -300m;
		max.y = 500m;
	};
	sequence { class = ORDER_UDIACS; proxClass = ORDER_UNUQTAS; order = ORDER_NOBELOW; }
}  /  cBase  cNuqtaLikeLower?  _;


cDiacriticLower { 
	collision {
		flags = CLEAR_IGNORE(collision.flags);
		flags = SET_FIX(collision.flags);
		min.x = -300m; // making this larger than ideal fixes \u0628\u0650\u06CC\u062C
		max.x = 300m;
		min.y = -1200m; // needed to get below nuqtas for sure; eg \u062A\u0648\u0641\u0650\u06CC\u0642
		max.y = 300m;
	};
	sequence { class = ORDER_LDIACS; proxClass = ORDER_LNUQTAS; order = ORDER_NOABOVE; }
}  /  cBase  cNuqtaLikeUpper?  _;


cDiacriticUpper { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -250m;
	max.x = 250m;
	min.y = -300m;
	max.y = 500m;
} };


cDiacriticLower { collision {
	flags = CLEAR_IGNORE(collision.flags);
	flags = SET_FIX(collision.flags);
	min.x = -300m; // making these larger than ideal fixes \u0628\u0650\u06CC\u062C
	max.x = 300m;
	min.y = -800m;
	max.y = 300m;
} };

endif; // (collfix >= 2) - shift fixes


// Isolate and final forms can be kerned, as indicated by glyph attribute collision.flags.

/******
if (overlapKern == none)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = 0;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == wide)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
//	max.x = MAXKERN; min.x = MINKERN_TIGHT; margin = KERNMARGIN_MED;
    // min/max.y are omitted for kernable glyphs
} };

endif;

if (overlapKern == medium)
******/


// Don't let a single-letter word kern underneath following segment:
cIso { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
	max.x = MAXKERN; min.x = (@S.advance.x * -1) - collision.margin;
    // min/max.y are omitted for kernable glyphs
} }
	/  cSpace  _  cNuqtaLike?  DIACS  cSpace=S  cPostKernable=N;


// For short sequences (two base chars) ending with bariyeh,
// kern against the bariyeh tail, not the initial.

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0, kernLsb + 90m);  // 90m = bariyeh's rsb
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cNoJoin?  c_initial cNuqtaLike? DIACS [c_medial cNuqtaLike? DIACS]? 
		gBariyehFin=F;

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = max(0m, kernLsb + @N.kernRsb + pairKern);
	max.x = MAXKERN; min.x = MINKERN + minKernDelta;
    // min/max.y are omitted for kernable glyphs
} }
	/  _  cNuqtaLike?  DIACS  cNoJoin?  cPostKernable=N;

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN;
    // min/max.y are omitted for kernable glyphs
} };

/******
endif;

if (overlapKern == tight)

cKernable { collision {
	flags = SET_FIX(collision.flags);
	flags = SET_KERN(collision.flags);
	margin = STDMARGIN;
	max.x = MAXKERN; min.x = MINKERN_TIGHT;
    // min/max.y are omitted for kernable glyphs
} };

endif;
******/

cls_excludingGlyphs { collision { flags = CLEAR_FIX(collision.flags); exclude.glyph = 0 }};

// Note that most nuqtas will have been previously marked not-fix, unless they are contiguous to
// height-adjusted kafs.

/////cKernable { collision.flags = CLEAR_FIX(collision.flags) }; - if kerning is done earlier

endpass;  // pass 9

endif; // (collFix > 0)


// We put the actual collision fixing a separate pass just because it makes debugging easier.

if (collFix > 0)
pass(10) { CollisionFix = 4; AutoKern = true }
// Perform diacritic-related fixing.
endpass;
endif;

#endif // DO_COL_FIX


/////#include "awami_tweaks.gdh"

endtable;

